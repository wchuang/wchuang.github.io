<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frank&#39;s blog - Developer, coffee lover and traveler</title>
    <description>My name is Frank, an iOS developer from Taiwan. Currently, I work and live in Shanghai, China.
</description>
    <link>http://blog.wchuang.me/</link>
    <atom:link href="http://blog.wchuang.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 25 Jun 2019 19:38:53 +0800</pubDate>
    <lastBuildDate>Tue, 25 Jun 2019 19:38:53 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>iOS 介面渲染及優化</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;這篇文章主要想要整理一下 iOS 上介面如何渲染以及怎麼優化，雖說是 iOS，但其實原理都是一樣的。分為下列三個知識點來討論：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;圖片如何從 raw data 呈現在螢幕上？&lt;/li&gt;
  &lt;li&gt;哪些情況下會造成介面顯示不流暢？&lt;/li&gt;
  &lt;li&gt;要如何解決這些問題？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;圖片如何顯示?&lt;/h2&gt;

&lt;p&gt;圖片如何從最一開始拿到的 raw data，最後展現在螢幕上讓使用者看到？所謂的 raw data 可能會從網路或者 bundle 的一張圖片取得，然後經由 CPU 計算解碼，GPU 渲染至緩存區，最後與硬體同步顯示在螢幕上。概觀圖如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/vsync/vsync.001.jpeg&quot; alt=&quot;V-sync&quot; /&gt;&lt;/p&gt;

&lt;p&gt;傳統 CRT 顯示器在顯示影像會由上到下垂直掃描，掃描完成後就會呈現一個 Frame 的完整畫面，同時電子槍會回到初始位置繼續下一次的掃描。為了讓系統 Controller 知道什麼時候掃描完成並要開始下一次掃描，顯示器會發出定時信號。&lt;/p&gt;

&lt;p&gt;定時信號又分為&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;1. 水平同步信號(H-Sync): 當顯示器完成當前的行掃描並要換到新的一行時。
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;2. 垂直同步信號(V-Sync): 當一個 Frame 完成掃描並繪製完成，電子槍回復到初始位置，準備下一個 Frame 的掃描時。&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;垂直同步信號(V-Sync)也就是所謂的 FPS，顯示器刷新的頻率，也是我們用來評估是否畫面造成卡頓的因素之一。&lt;/p&gt;

&lt;p&gt;當系統 Controller 收到來自顯示器的 V-Sync 訊號量後，它就知道螢幕已經完成一次顯示。這時候它會向 FrameBuffer 讀取下一個 Frame 的資料。&lt;/p&gt;

&lt;p&gt;Framebuffer 在 Wiki 的定義：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;A framebuffer (frame buffer, or sometimes framestore) is a portion of RAM[1]
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; containing a bitmap that drives a video display. 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;It is a memory buffer containing a complete frame of data.[2] 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;Modern video cards contain framebuffer circuitry in their cores. 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;This circuitry converts an in-memory bitmap into a video signal 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;that can be displayed on a computer monitor. &lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;所以我們知道它是一塊記憶體緩存區，負責存放由 CPU/GPU 處理後的一塊完整 Frame data。&lt;/p&gt;

&lt;p&gt;而現代的 framebuffer 幾乎都為雙緩存機制。這個機制下，GPU 會先渲染一個 Frame 的資料存入第一個 buffer 裡，讓 Controller 可以讀取。當下一個 Frame 渲染完成後，GPU 會把 Controller 的指針指向第二個 buffer，讓 Controler 讀取第二個 buffer 的資料。&lt;/p&gt;

&lt;p&gt;但是如果 GPU 每次渲染完第二個 Frame 後就讓 Controller 讀取第二個 buffer 的資料，有可能因為 Controller 還未讀取完第一個 Frame 的資料就切換到第二個，造成了畫面畫面撕裂現象。畫面的上半部顯示舊的影像，下半部顯示了新的影像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../images/vsync/screen_tearing.jpg&quot; alt=&quot;Screen_tearing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那麼要如何解決這個問題？&lt;/p&gt;

&lt;p&gt;GPU 也有 V-Sync 的同步機制，當 V-Sync 開啟時，GPU 會等待顯示器的 V-Sync 信號發出後才進行下一個 Frame 的渲染以及緩存區更新。這樣便解決了畫面撕裂問題，但是也因為沒辦法先行處理下一個 Frame 的渲染，所以可能會有延遲的情況產生。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;為什麼卡頓?&lt;/h2&gt;

&lt;p&gt;在 iOS 中，當一個 V-Sync 通知到來的時候，Core Animation 會利用 CADisplayLink 通知 APP，APP main thread 會開始在 CPU 計算顯示內容，如：view 的創建、Frame 的計算、圖片解碼、文本繪製等。然後 CPU 會將計算好的內容提交給 GPU，由 GPU 進行變換、合成、渲染，最後將渲染的結果存到緩存區中，讓 Controller 讀取、顯示在螢幕上並等待下一次 V-Sync 到來。&lt;/p&gt;

&lt;p&gt;上述是一個完整的 V-Sync 圖像處理流程。但是如果在一次的 V-Sync 時間內，CPU 及 GPU 沒辦法即時完成任務並提交到緩存區內，這一次的 Frame 就會被丟棄。也就是說在下一個 V-Sync 來臨時，Controller 依舊讀取到 buffer 內的舊資料並顯示，這就是造成介面卡頓的原因。&lt;/p&gt;

&lt;p&gt;所以，CPU 或 GPU 不論哪個阻礙了顯示流程，都會造成掉幀情況。所以開發時，需要分別對 CPU 及 GPU 壓力進行評估及優化來避免這類的問題。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;如何解決?&lt;/h2&gt;

&lt;p&gt;要知道如何解決前，需要先了解 CPU 及 GPU 在處理圖像時，都做了哪些事情。&lt;/p&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;對象創建&lt;/p&gt;

    &lt;p&gt;對象的創建會涉及到內存的分配、屬性調整、計算 retain count 等的操作，相對來說較耗用 CPU 資源。所以可以盡量利用比較__輕量的對象來取代__。如：用 struct 取代 class 來定義 model，或者當不需要響應使用者觸摸事件的控件，可以使用 CALayer 來代替 UIView。&lt;strong&gt;多復用已創建的對象&lt;/strong&gt;，可以建立緩存存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;對象調整&lt;/p&gt;

    &lt;p&gt;對象的屬性調整也是很消耗 CPU 的地方。由於 UIView 關於顯示相關的屬性，如 frame/bounds/transform 等實際上也是映射到 CALayer 屬性，所以修改 UIView 的這些屬性的時候，實際上消耗的性能遠大於其他的屬性。而當 UIView 進行層級調整的時候，UIView 及 CALayer 之間也會出現多次方法調用以及通知。&lt;/p&gt;

    &lt;p&gt;我這邊對 CALayer 做了擴展並加了自定義屬性來測試，發現 &lt;strong&gt;CALayer 會在 runtime 時自己添加上屬性方法&lt;/strong&gt;。若是對 UIView 做擴展及自定義屬性的話，在調用時會出現找不到方法造成 crash，你需要自己在 runtime 添加屬性方法。&lt;/p&gt;

    &lt;p&gt;```
 // MyLayer
 @interface MyLayer : CALayer
 @end&lt;/p&gt;

    &lt;p&gt;@interface MyLayer (MyTest)
 @property (copy, nonatomic) NSString *name;
 @end&lt;/p&gt;

    &lt;p&gt;@implementation MyLayer
 @end&lt;/p&gt;

    &lt;p&gt;@implementation MyLayer (MyTest)
 @end&lt;/p&gt;

    &lt;p&gt;// Test
 MyLayer *layer = [[MyLayer alloc] init];
 [self.view.layer addSublayer:layer];
 layer.backgroundColor = UIColor.redColor.CGColor;&lt;/p&gt;

    &lt;p&gt;for (int i = 0; i &amp;lt; 1000000; i++) {
     layer.name = [NSString stringWithFormat:@”MyLayer: %d”, i];
     layer.frame = CGRectMake(50, 50, 10, 10);
     NSLog(@”layer name: %@”, layer.name);
 }
 ```&lt;/p&gt;

    &lt;p&gt;```
 // MyView
 @interface MyView : UIView
 @end&lt;/p&gt;

    &lt;p&gt;@interface MyView (MyTest)
 @property (copy, nonatomic) NSString *viewName;
 @end&lt;/p&gt;

    &lt;p&gt;@implementation MyView
 @end&lt;/p&gt;

    &lt;p&gt;@implementation MyView (MyTest)
 @end&lt;/p&gt;

    &lt;p&gt;// Test
 MyView *view = [[MyView alloc] init];
 view.frame = CGRectMake(0, 0, 100, 100);
 view.viewName = @”MyView”; // Crash!!
 [self.view addSubview:view];
 ```&lt;/p&gt;

    &lt;p&gt;觀察調用棧會發現在設定自定義屬性 &lt;code&gt;name&lt;/code&gt; 的時候，底層做了很多事情，包含了添加屬性方法、尋找屬性方法、設定屬性內容、發送 KVO 通知、&lt;code&gt;CA::Layer::begin_change()&lt;/code&gt;、&lt;code&gt;CA::Layer::end_change()&lt;/code&gt;、&lt;code&gt;CA::Transaction::ensure_compact()&lt;/code&gt;、加鎖等的操作。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;../images/vsync/custom_layer.png&quot; alt=&quot;Custom_layer&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;對象銷毀&lt;/p&gt;

    &lt;p&gt;對象銷毀雖然消耗的資源不明顯，但若是累積起來也是不容忽視。尤其是一次釋放大量對象的時候。也可以盡可能的放在 background thread 執行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;佈局計算&lt;/p&gt;

    &lt;p&gt;佈局計算是最常見消耗系統資源的地方。如果能先在 background thread 計算好並作緩存就能避免這些問題。但上述也提到，調整佈局相關屬性(frame/bounds/center)其實都會對應到 CALayer 層級操作，還有同步通知問題，是非常消耗性能的地方。所以最好__先做預先計算及緩存，並且一次性的調整，而不要多次、頻繁的改變這些屬性__。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本計算&lt;/p&gt;

    &lt;p&gt;如果在介面上有大量的文本需求（如：facebook news feed 或微信朋友圈），常常需要計算文本寬、高度，可以利用 &lt;code&gt;NSAttributedString&lt;/code&gt; 中的 &lt;code&gt;[string boundingRectWithSize:options:context:];&lt;/code&gt;、&lt;code&gt;[string drawWithRect:options:context:];&lt;/code&gt; 這兩個方法來實現以提升效能，由於是 thread safe，所以可以放在 background thread 執行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本渲染&lt;/p&gt;

    &lt;p&gt;螢幕上能看到的所有文本內容控件，包含 UIWebView，其底層都是通過 &lt;code&gt;CoreText&lt;/code&gt; 來排版並繪製成 &lt;code&gt;Bitmap&lt;/code&gt; 顯示。常見的控件（UILabel、UITextView）等，其排版以及繪製都是在主線程進行。所以當有大量的文本需要顯示的時候，CPU 的壓力就會非常大。&lt;/p&gt;

    &lt;p&gt;對此解決方式可以__自定義一個文本控件，並用&lt;code&gt;TextKit&lt;/code&gt;或&lt;code&gt;CoreText&lt;/code&gt;對文本異步繪製__。&lt;code&gt;CoreText&lt;/code&gt; 對象創建好後，能直接取得文本的寬度高度等訊息。&lt;strong&gt;避免了多次計算（調整 UILabel 大小的時候計算一次、UILabel 繪製的時候內部又再算一次）&lt;/strong&gt;。且&lt;code&gt;CoreText&lt;/code&gt;對象佔用內存較少，可以緩存下來做多次復用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖片解碼&lt;/p&gt;

    &lt;p&gt;當你用 UIImage 或 CGImageSource 的那幾個方法創建圖片的時候，圖片資料並不會馬上被解碼。當圖片設置到 UIImageView 或 CALayer.contents 時，並且 CALayer 被提交到 GPU 渲染前，CGImage 中的資料才得以解碼。由於這一步是 UI 操作，會發生在主線程，且不可避免。優化方式可以先在 &lt;strong&gt;background thread 把圖片繪製到 CGBitmapContext 中，然後由 Bitmap 直接創建圖片&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖像繪製&lt;/p&gt;

    &lt;p&gt;圖像繪製指的是使用以 CG 開頭的底層方法，把圖像繪製到畫布中，然後從畫布創建圖片並顯示的一個過程。最常見的地方就是在&lt;code&gt;[UIView drawRect:]&lt;/code&gt;方法裡面。由於 CoreGraphic 的方法是 thread safe 的，所以可以在 background thread 繪製。&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;
 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
     CGContextRef contextRef = CGBitmapContextCreate();
     // Draw your context.
     CGImageRef imageRef = CGBitmapContextCreateImage(contextRef);
     CGContextRelease(contextRef);
     dispatch_async(dispatch_get_main_queue(), ^{
         layer.contents = (__bridge id _Nullable)(imageRef);
         CGImageRelease(imageRef);
     });
 });
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gpu&quot;&gt;GPU&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;紋理渲染&lt;/p&gt;

    &lt;p&gt;所有的 Bitmap，不論是圖片或是文本的內容，最終都是要由內存提交到顯示卡記憶體，並綁定為 GPU 的 Texture。所以不管是提交的過程或是 GPU 調整和渲染 Texture 的過程，都要消耗不少 GPU 的資源。&lt;/p&gt;

    &lt;p&gt;當在較短時間內顯示大量的圖片時（如 UITableView 存在很多圖片並快速滑動的時候），CPU 佔用率很低，GPU 佔用率非常高，此時介面依然會掉幀。避免此情況的方法只能__避免在短時間內的大量圖片顯示，盡可能將多張圖片合併成一張顯示__。&lt;/p&gt;

    &lt;p&gt;當圖片過大，超過 GPU 的最大 Texture size 時，圖片需要先由 CPU 進行預處理，這對 CPU 及 GPU 都會帶來額外的資源消耗。可以從這個網站查看各個 iPhone 機型對應的 &lt;a href=&quot;http://iosres.com/&quot;&gt;MAX Texture size&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;視圖混合&lt;/p&gt;

    &lt;p&gt;當多個 View（CALayer）重疊在一起的時候，GPU 會先把它們混合到一起。如果視圖結構過於複雜，混合的過程也會消耗很多 GPU 資源。為了減少這種情況的資源消耗，可以盡量__減少 view 的層級以及數量，並設置 opaque 為不透明，減少計算 background color 時的 alpha 合成__。也可以將多張視圖預先渲染為一張圖片顯示。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖形生成&lt;/p&gt;

    &lt;p&gt;CALayer 的 border、圓角、陰影、遮罩、CASharpLayer 的矢量圖形顯示，通常會造成離屏渲染（Off-Screen Rendering）。&lt;/p&gt;

    &lt;p&gt;GPU 的屏幕渲染分為兩種：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;On-Screen Rendering：指的是 GPU 的渲染操作在當前用於顯示的緩存區中。&lt;/li&gt;
      &lt;li&gt;Off-Screen Rendering：指的是 GPU 的渲染操作不在當前用於顯示的緩存區中，而是另外建立一個緩存區做渲染操作。如果我們__重寫了 drawRect: 方法，並使用了 Core Graphics 方法進行繪製得到 Bitmap 後在交給 GPU 顯示__，也算是一種離屏渲染，因為是由 CPU 渲染。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;而離屏渲染（Off-Screen Rendering）的代價是很高的，原因在於：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;創建新的緩存區&lt;/strong&gt;：系統必須多花費資源重新創建。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;上下文切換&lt;/strong&gt;：必須先由 On-Screen 切換到 Off-Screen 環境，待 Off-Screen Rendering 結束後，把渲染結果同步到 On-Screen 環境。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;所以我們要避免離屏渲染造成系統無謂的資源浪費，可以設置 &lt;code&gt;CALayer.shouldRasterize&lt;/code&gt; 屬性為 YES，使得在離屏渲染發生的時候會將渲染後的內容緩存起來，在下一個 Frame 渲染時可以直接復用。但如果你又同時設置了 border、圓角 等其他屬性，緩存將不會起作用。&lt;/p&gt;

    &lt;p&gt;所以最好的方式，還是要避免上述的圓角、border、mask 等屬性的調用，可以用 CPU 渲染來代替。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Framebuffer&quot;&gt;Framebuffer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Screen_tearing&quot;&gt;Screen_tearing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/quartzcore/cadisplaylink&quot;&gt;CADisplayLink&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/&quot;&gt;ibireme大神文章&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 23:56:57 +0800</pubDate>
        <link>http://blog.wchuang.me/2019/06/24/ios-interfaces-rendering-and-refactor/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2019/06/24/ios-interfaces-rendering-and-refactor/</guid>
        
        
      </item>
    
      <item>
        <title>如何使用 @autoclosure 設計 Swift APIs</title>
        <description>&lt;p&gt;Swift 中的 &lt;code&gt;@autoclosure&lt;/code&gt; 屬性，可以讓你定義一個 &lt;code&gt;可自動取得一個閉包 (closure) 內的包裹 (wrapped)&lt;/code&gt; 的參數。它主要用於延緩執行時間，而不是當這個參數傳入的時候就直接使用，因為執行的動作可能有點耗時。這麼說有點繞口，下面是一個官方 Swift 標準函式庫的 &lt;code&gt;assert&lt;/code&gt; 例子，我們來看看 Apple 是怎麼實現這個方法的。&lt;/p&gt;

&lt;p&gt;由於 &lt;code&gt;assert&lt;/code&gt; 只有在 &lt;code&gt;debug&lt;/code&gt; 模式下才會被觸發，在 &lt;code&gt;release&lt;/code&gt; 模式下會被返回而不會執行 &lt;code&gt;expression&lt;/code&gt;，完整的實作請看源碼: &lt;a href=&quot;https://github.com/apple/swift/blob/master/stdlib/public/core/Assert.swift&quot;&gt;Assert.swift&lt;/a&gt;&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;func assert(_ expression: @autoclosure () -&amp;gt; Bool, 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			_ message: @autoclosure () -&amp;gt; String) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	guard let isDebug else &amp;#x7b; return &amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	if !expression() &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		assertionFailure(message())
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;如果 &lt;code&gt;assert&lt;/code&gt; 的實作方式是用一般的閉包實現，那你會這樣呼叫：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;assert(&amp;#x7b; someCondition() &amp;#x7d;, &amp;#x7b; &quot;hey, it failed.&quot; &amp;#x7d;)&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;現在你只需要這樣即可，不用在傳入一個閉包參照。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;assert(someCondition(), &quot;hey, it failed.&quot;)&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;那麼如何運用 &lt;code&gt;@autoclosure&lt;/code&gt; 這個方便的特性在實際 APIs 設計上面呢？&lt;/p&gt;

&lt;h3 id=&quot;inlining-assignments&quot;&gt;1. Inlining assignments&lt;/h3&gt;

&lt;p&gt;在方法呼叫的時候，把一個表達式當做一個參數傳入。一般在 iOS 處理畫面動畫你會用到：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;UIView.animate(withDuration: 0.25) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	view.frame.origin.y = 100
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;在 &lt;code&gt;@autoclosure&lt;/code&gt; 中，我們定義一個方法來化簡這樣的呼叫方式。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;func animate(_ animation: @autoclosure @escaping () -&amp;gt; Void, 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				duration: TimeInterval = 0.25) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	UIView.animate(withDuration: duration, animations: animation)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;如此一來，我們只需要傳入一個特定操作表達式，不用再寫額外的 &lt;code&gt;{}&lt;/code&gt;。
增加了程式碼的可讀性以及降低複雜度。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;animate(view.frame.origin.y = 100)&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h3 id=&quot;passing-errors-as-expressions&quot;&gt;2. Passing errors as expressions&lt;/h3&gt;

&lt;p&gt;我們常常會需要寫一個工具來處理 errors 的各種情況，此時使用 &lt;code&gt;@autoclosure&lt;/code&gt; 就變得非常方便。
例如：我們寫一個 &lt;code&gt;extension&lt;/code&gt; 來擴展 &lt;code&gt;Optional&lt;/code&gt;，讓我們可以容易的解包 (unwrap) 或拋出異常 (throwing API)。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;extension Optional &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func unwrapOrThrow(_ errorExpression: @autoclosure () -&amp;gt; Error) throws -&amp;gt; Wrapped &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		guard let value = self else &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			throw errorExpression()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		return value
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;這跟上述的 &lt;code&gt;assert&lt;/code&gt; 一樣，我們只需要關注在錯誤的表達式上面，而不需要每次都去判斷是否解包成功 (unwarp)。
我們現在可以這樣使用 &lt;code&gt;unwarpOrThrow&lt;/code&gt; API：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let name = try argument(at: 1).unwarpOrThrow(ArgumentError.missingName)&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h3 id=&quot;type-inference-using-default-values&quot;&gt;3. Type inference using default values&lt;/h3&gt;

&lt;p&gt;很多時候當我們從 &lt;code&gt;Dictionary&lt;/code&gt;, &lt;code&gt;TextField.text&lt;/code&gt;, &lt;code&gt;UserDefaults&lt;/code&gt; 或者其他地方取值的時候，常常會碰到可選值 (optional value) 的情況。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let coins = (dictionary[&quot;numberOfCoins&quot;] as? Int) ?? 100&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;這樣的寫法用了很多操作符號，程式碼變得難以閱讀。
這時候可以用 &lt;code&gt;@aotuclosure&lt;/code&gt; 來改善寫法。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let coins = dictioanry.value(forKey: &quot;numberOfCoins&quot;, defaultValue: 100)&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;這邊賦予了一個預設值給 &lt;code&gt;coins&lt;/code&gt;，當內容為 nil 的情況。這樣是不是好閱讀多了，也不需要每次都去判斷是否為 nil。:grin:
不過我們還需要一個方法擴展 Dictionary。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;extension Dictionary where Value == Any &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func value&amp;lt;T&amp;gt;(forKey key: Key, defaultValue: @autoclosure () -&amp;gt; T) -&amp;gt; T &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		guard let value = self[key] as? T else &amp;#x7b; return defaultValue() &amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		return value
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section&quot;&gt;結論&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;@autoclosure&lt;/code&gt; 是一個很有用的工具，讓你可以關注在你想處理的事情上面，並減少了重複性判斷，大大增加了程式碼的可讀性。&lt;/p&gt;

&lt;h3 id=&quot;ref&quot;&gt;Ref.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.swiftbysundell.com/posts/using-autoclosure-when-designing-swift-apis&quot;&gt;swiftbysundell&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Mar 2019 16:31:08 +0800</pubDate>
        <link>http://blog.wchuang.me/2019/03/02/autoclosure-swift-apis/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2019/03/02/autoclosure-swift-apis/</guid>
        
        
        <category>aotuclosure,</category>
        
        <category>swift,</category>
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>那些你很少用的 Swift GCD 方法</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/dispatch&quot;&gt;Grand Central Dispatch&lt;/a&gt; (GCD) 相信每個 iOS 開發者都不陌生，它是蘋果提供用來操作多執行緒的一種底層技術，你可以選擇在串行 (serial) 或並行 (concurrent) 的 queue 中執行同步 (synchronous) 或者非同步 (asynchronous) 的任務，這邊就不多說了，最常看到的方法就是：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;DispatchQueue.global().async &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	// 耗時操作
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	DispatchQueue.main.async &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		// UI 更新 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;但除此之外，GCD 還有很多很少被使用但是令人驚豔的方法，這邊會介紹 4 種這類的方法，大家下次可以試著在專案中使用看看，相信會有很大的效果。&lt;/p&gt;

&lt;h1 id=&quot;dispatchworkitem-&quot;&gt;1. 利用 DispatchWorkItem 取消等待的任務&lt;/h1&gt;

&lt;p&gt;有些人對於 GCD 有一個 &lt;strong&gt;錯誤認知&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦排定了 GCD 任務就沒辦法被取消，只有 Operation 才可以。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;實際上在 iOS 8 及 macOS 10.10 之後可以使用 DispatchWorkItem 來做到。&lt;/p&gt;

&lt;p&gt;應用場景：&lt;/p&gt;

&lt;p&gt;假設我們有一個 search bar 讓使用者進行關鍵字搜尋，當收到關鍵字時會向後端 API 發送搜尋請求。但考量到使用者打字的速度，不可能每次輸入一個字就發出網路請求，這可能會造成不必要的網路流量以及伺服器負擔。所以我們可以偵測當使用者輸入閒置超過 0.25 秒後才發送一個請求。&lt;/p&gt;

&lt;p&gt;底下是一個例子，我們可以簡單的用 DispatchWorkItem，不用 Timer 或 Operation 的複雜操作。也可以直接用 closure 閉包注入 GCD 中，不需要 @objc 或是 #selector。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;class SearchViewController: UIViewController, UISearchBarDelegate &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	private var pendingRequestWorkItem: DispatchWorkItem?
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	// MARK: - UISearchBarDelegate	
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		// Cancel the pending work item
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		pendingRequestWorkItem?.cancel()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		// Build a request in a work item
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let requestWorkItem = DispatchWorkItem &amp;#x7b; [weak self] in
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;13&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			self?.resultLoader.loadRequests(forQuery: searchText)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;14&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;15&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;16&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		// Save it and execute after 250ms
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;17&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		pendingRequestWorkItem = requestWorkItem
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;18&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(250), 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;19&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		                               execute: requestWorkItem)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;20&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;21&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h1 id=&quot;dispatchgroup-&quot;&gt;2. 利用 DispatchGroup 執行一系列的任務&lt;/h1&gt;

&lt;p&gt;有時候我們希望可以做完一系列的任務 {A, B, C} 後，再做其他的任務 D。{ A, B, C } -&amp;gt; D。例如：在建立 model 之前會有多個 API 的 request，待全部 response 回來後才組成需要的 model。&lt;/p&gt;

&lt;p&gt;這時候可以利用 DispatchGroup 來達成同步任務。我們只需要注意 &lt;code&gt;enter()&lt;/code&gt; 以及 &lt;code&gt;leave()&lt;/code&gt; 的呼叫是否一致。&lt;/p&gt;

&lt;p&gt;DispatchGroup 有另個好處可以開多個 DispatchGroup queue 異步的執行，而每個 queue 裡面的任務又可以同步完成。&lt;/p&gt;

&lt;p&gt;下面一個簡單的例子，從不同 datasource 取得資料，全部完成後存入 NoteCollection。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;// Create a group to synchronize our tasks.
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let groip = DispatchGroup()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;// NoteCollection is a thread-safe collection class for storing notes.
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let collection = NoteCollection()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;// The &#39;enter	()&#39; method increments the group&#39;s task count
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;group.enter()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;localDataSource.load &amp;#x7b; notes in 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	collection.add(notes)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	// while the &#39;leave()&#39; method decrements it
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	group.leave()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;13&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;14&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;15&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;group.enter()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;16&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;iCloudDataSource.load &amp;#x7b; notes in 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;17&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	collection.add(notes)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;18&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	group.leave()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;19&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;20&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;21&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;group.enter()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;22&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;backendDataSource.load &amp;#x7b; notes in 
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;23&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	collection.add(notes)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;24&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	group.leave()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;25&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;26&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;27&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;// This closure will be called when the group&#39;s task count reaches 0
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;28&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;group.notify(queue: .main) &amp;#x7b; [weak self] in
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;29&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	self?.render(collection)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;30&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;上面的代碼重複的部份有點多，我們可以做一個 Array 的擴展來優化：&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;extension Array where Element == DataSource &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func load(completion: @escaping (NoteCollection) -&amp;gt; Void) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let group = DispatchGroup()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let collection = NoteCollection()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		for dataSource in self &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			group.enter()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			dataSource.load &amp;#x7b; notes in
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;13&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				collection.add(notes)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;14&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				group.leave()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;15&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;16&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;17&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;18&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		group.notify(queue: .main) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;19&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;20&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			completion(collection)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;21&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;22&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;23&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;基於以上擴展，我們可以這樣呼叫&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let dataSources: [DataSource] = [
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	localDataSource,
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	iCouldDataSource,
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	backendDataSource
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;]
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;dataSources.load &amp;#x7b; [weak self] collection in
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	self?.render(collection)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h1 id=&quot;dispatchsemaphore-&quot;&gt;3. 利用 DispatchSemaphore 鎖住非同步的任務&lt;/h1&gt;

&lt;p&gt;雖然 DispatchGroup 提供了同步的方法等待所有任務執行完成，但對於不同 DispatchGroup queue 來說，彼此還是异步的進行。DispatchSemaphore 可以鎖住某個 DispatchGroup queue 的執行，藉以達成同步的效果。&lt;/p&gt;

&lt;p&gt;跟 DispatchGroup 一樣，DispatchSemaphore API 也很簡單，也是利用 &lt;code&gt;signal()&lt;/code&gt; 或 &lt;code&gt;wait()&lt;/code&gt; 來增加或減少內部計數。在呼叫 &lt;code&gt;signal()&lt;/code&gt; 前呼叫 &lt;code&gt;wait()&lt;/code&gt; 會 block 目前的操作一直到 &lt;code&gt;signal()&lt;/code&gt; 被呼叫。&lt;/p&gt;

&lt;p&gt;我們修改上面的例子，並另外建立一個 global queue 來加入 Semaphore 方法，因為呼叫 &lt;code&gt;wait()&lt;/code&gt; 會 block 當前的 queue。成功返回 NoteCollection，失敗則丟出錯誤。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;extension Array where Element == DataSource &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func load() throws -&amp;gt; NoteCollection &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let semaphore = DispatchSemaphore(value: 0)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		var loadedCollection: NoteCollection?
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let loadingQueue = DispatchQueue.global()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		loadingQueue.async &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			self.load(onQueue: loadingQueue) &amp;#x7b; collection in
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;13&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;14&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				loadedCollection = collection
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;15&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;16&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				// Unblock
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;17&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;				semaphore.signal()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;18&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;19&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;20&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;21&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		// Block and wait
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;22&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		semaphore.wait(timeout: .noew() + 5)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;23&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;24&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		guare let collection = loadedCollection else &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;25&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;26&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;			throw NoteLoadingError.timeout
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;27&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;28&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;29&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		return collection
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;30&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;31&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;同步的呼叫方式&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let dataSource: [DataSource] = [
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	localDataSource,
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	iCloudDataSource,
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	backendDataSource
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;]
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;do &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	let collection = try dataSource.load()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	output(collection)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d; catch &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	output(error)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;h1 id=&quot;dispatchsource-&quot;&gt;4. 利用 DispatchSource 監聽檔案是否被修改&lt;/h1&gt;

&lt;p&gt;這個鮮為人知的方法可以讓我們監控檔案是否被修改過，&lt;code&gt;在線編輯&lt;/code&gt;的功能就可以利用這個方式實作出來。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DispatchSource&lt;/code&gt; 可以有很多種來源，例如：Timer source, User data, file system or memory pressure event，這裡我們用 file system 示範。直接看 code 吧。&lt;/p&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;class FileObserver &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	private let file: File
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	private let queue: DispatchQueue
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	private var source: DispatchSourceFileSystemObject?
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;6&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;7&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	init(file: File) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;8&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;9&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		self.file = file
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;10&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		self.queue = DispatchQueue(label: &quot;com.test.fileobserver&quot;)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;11&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;12&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;13&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	func start(closure: @escaping() -&amp;gt; Void) &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;14&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;15&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let path = (file.path as NSString)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;16&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let fileSystemRepresentation = path.fileSystemRepresentation
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;17&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;18&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let fileDescriptor = open(fileSystemRepresentation, O_EVTONLY)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;19&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;20&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		let source = DispatchSource.makeFileSystemObjectSource(fileDescriptor: fileDescriptor, eventMask: .write, queue: queue)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;21&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;22&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		source.setEventHandler(handler: closure)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;23&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		source.resume()
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;24&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;25&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;		self.source = source
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;26&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	&amp;#x7d;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;27&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;figure class=&quot;code-highlight-figure&quot;&gt;&lt;div class=&quot;code-highlight&quot;&gt;&lt;pre class=&quot;code-highlight-pre&quot;&gt;&lt;div data-line=&quot;1&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;let observer = try FileObserver(file: file)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;2&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;3&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;observer.start &amp;#x7b;
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;4&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;	print(&quot;File was changed&quot;)
&lt;/div&gt;&lt;/div&gt;&lt;div data-line=&quot;5&quot; class=&quot;code-highlight-row numbered&quot;&gt;&lt;div class=&quot;code-highlight-line&quot;&gt;&amp;#x7d;&lt;/div&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;

&lt;p&gt;總結下來，GCD 還是挺厲害的也埋藏了一些好用的功能，比起利用 NSTimer 或者 Operation 可能會產生的問題小很多，也更安全一些！各位看倌可以多多挖掘 GCD 的應用場景。Happy Coding!&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.swiftbysundell.com/posts/a-deep-dive-into-grand-central-dispatch-in-swift&quot;&gt;A deep dive into Grand Central Dispatch in Swift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Nov 2018 15:03:08 +0800</pubDate>
        <link>http://blog.wchuang.me/2018/11/04/swift-gcd/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2018/11/04/swift-gcd/</guid>
        
        
        <category>gcd,</category>
        
        <category>swift,</category>
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>What Is Mmap and How It Works?</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;MMAP(Memory-mapped file), 是一種源於 Unix/Linux 作業系統內存映射文件的方法，主要用於&lt;strong&gt;增加 I/O 存取效能&lt;/strong&gt;，尤其大文件效果更顯著。它在進程 process 中開闢一段&lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;虛擬內存&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;逐一字節的將一份文件或檔案從磁碟位置對應到該虛擬位置&lt;/em&gt;，這樣使得 process 可以直接操作該虛擬內存，如同操作該文件，而不需要調用 read/write 等系統方法。同時也減少了一次從文件拷貝的動作。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;原理&lt;/h1&gt;

&lt;p&gt;mmap 實現原理主要分為三個階段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start MMAP in process, creating a virtual mapping zone on virtual address space:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Process request a &lt;code&gt;mmap&lt;/code&gt; system fuction in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek a continuous and idle virtual address space in vitual memory address of current process.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Allocate a &lt;code&gt;vm_area_struct&lt;/code&gt; struct for this virtual address space, and initialize the struct.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Insert the struct to linked list or tree of virtual address space of process.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Request a &lt;code&gt;mmap&lt;/code&gt; system fuction in kernal-space, not in user-space, and implement the mapping relationship between the disk address of file and virtual address space of current process:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;After allocating a new virtual address space, it will find the file descriptor in file descriptor table by the pointer of un-mapped files. And link to the struct file of every un-mapped file through the file descriptor in kernal’s opened file set. Every struct file will maintain a opened file in kernal one by one.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Link to module of &lt;code&gt;file_operations&lt;/code&gt; through the struct file and request function of &lt;code&gt;mmap&lt;/code&gt; in kernal-space, not in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code&gt;int mmap(struct file *filp, struct vm_area_struct *vma)&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; function in kernal will locate the file physical address in disk by &lt;code&gt;inode&lt;/code&gt; module.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Build a mapping relationship table between the disk address of file and virtual address space of current process. However, there is no data mapping in main memory from virtual address space.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process start to read data on this virtual address space, that will occur &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1&quot;&gt;&lt;code&gt;Page Fault&lt;/code&gt;&lt;/a&gt; and start copy document data from disk to main memory: (&lt;strong&gt;In step 1 and 2, there is only create virtual address space and compelte the mapping relationshop table, but the data do not copy into main memory yet. When starting read/write operations on process, just start to copy data.&lt;/strong&gt;)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;When process start to read or write data on mapping address on virtual address space, it find that it is not found on memory page. Due to there is only build a mapping and the file data is not copy to memory, so it occurs &lt;code&gt;Page Fault&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Kernal request a page fault handler after confirming there are no illegal operations.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek to the memory page in &lt;code&gt;swap cache&lt;/code&gt;, if not find, it will request &lt;code&gt;nopage&lt;/code&gt; function in order to create page from disk to main memory.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Then the process can do read/write operations on main memory, if the data be changed, system will update those changed content in mapped disk address after a while. (You can use &lt;code&gt;msync&lt;/code&gt; function to update data right now.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-2&quot;&gt;函數介紹&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;參數&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;start: mapping virtual address space 的開始位置，如果傳入 NULL，kernal 會自動選擇 page-aligned address。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;length: mapping space 長度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prot: 內存保護機制。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  PROT_EXEC  Pages may be executed.
  PROT_READ  Pages may be read.
  PROT_WRITE Pages may be written.
  PROT_NONE  Pages may not be accessed.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flags: 是否該映射區可以被其他 processes 看到。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  MAP_SHARED Share this mapping.
  MAP_SHARED_VALIDATE This flag provides the same behavior as MAP_SHARED except that MAP_SHARED mappings ignore unknown flags in flags.
  MAP_PRIVATE Create a private copy-on-write mapping.
  MAP_32BIT Put the mapping into the first 2 Gigabytes of the process address space. 
  MAP_ANON Synonym for MAP_ANONYMOUS. Deprecated.
  ...    
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fd: 文件描述詞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;offset: 文件位移量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;返回值&lt;/h5&gt;

&lt;p&gt;如果建立成功，會返回一個指標指向這個映射空間的位置。假設失敗，將會回傳 &lt;code&gt;MAP_FAILED (that is, (void *) -1)&lt;/code&gt;，以及 &lt;code&gt;errno&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;與一般文件存取差異&lt;/h1&gt;

&lt;p&gt;一般文件調用過程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process 發起讀取文件請求。&lt;/li&gt;
  &lt;li&gt;Kernal 通過尋找 file descriptor in file descriptor table，並且利用 kernal 中已開啟的文件集中的文件資訊找到該文件的 &lt;code&gt;inode&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;判斷該文件是否在&lt;a href=&quot;https://en.wikipedia.org/wiki/Page_cache&quot;&gt;頁緩存 page cache&lt;/a&gt; 中，如果存在則返回該文件內容。不存在則利用 &lt;code&gt;inode&lt;/code&gt; 定位到 physical address in disk，並拷貝文件內容到頁緩存中。之後再發起讀頁面請求，將頁緩存的資訊給該 process。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;總而言之，一般文件讀取為了提高效率及保護磁碟，會利用頁緩存技術。這樣造成讀文件的時候，需要先將文件從磁碟拷貝到頁緩存，但由於頁緩存在 kernal-space 中，不能被 user-space 訪問，所以必須將資料從頁緩存再拷貝到 user-space。&lt;strong&gt;這樣進行了兩次的資料拷貝&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而使用 mmap，利用建立新的 virtual address space 以及磁碟位置與 virtual address space 的映射，沒有進行文件拷貝。直到訪問資料時造成 &lt;code&gt;Page Fault&lt;/code&gt; 利用映射關係，&lt;strong&gt;只進行一次的資料拷貝&lt;/strong&gt;，就從磁碟拷貝至 user-space，讓 process 得以使用。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;優點&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;對文件存取繞過了 paging 技術操作，減少了資料的拷貝次數，並且利用 read/write in memory instead of I/O operations，大大提高效能。&lt;/li&gt;
  &lt;li&gt;內存映射文件可以只載入一部分內容到用戶空間，對於大型檔案非常有用。&lt;/li&gt;
  &lt;li&gt;實現了 user-space 及 kernal-space 的交互，兩空間的修改可以直接反映在映射區，並且被對方更新。&lt;/li&gt;
  &lt;li&gt;可以達到跨 process 溝通通信。&lt;/li&gt;
  &lt;li&gt;避免因為大量的 data I/O 造成的記憶體不足問題，&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-7&quot;&gt;如何確保不會讀到其他位址&lt;/h1&gt;

&lt;p&gt;MMAP 是利用自己的虛擬位址空間來處理 (必須先映射，否則無法透過 user-space 的虛擬記憶體存取)。所以其他 user-space 中的行程是沒辦法去存取這塊記憶體。因為其這塊超出的記憶體位址並沒有映射到它自己的虛擬記憶體位址，也因此當 user-space 存取超出的話，就會被作業系統踢出。&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;參考資料&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/huxiao-tee/p/4660352.html&quot;&gt;mmap分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap函數說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 18 Jun 2018 17:17:35 +0800</pubDate>
        <link>http://blog.wchuang.me/2018/06/18/what-is-mmap-and-how-it-works/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2018/06/18/what-is-mmap-and-how-it-works/</guid>
        
        
      </item>
    
      <item>
        <title>How to Make a Private CocoaPods?</title>
        <description>&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;CocoaPods is a great tool not only for adding open source code to your project, but also for sharing components across projects.&lt;/p&gt;

&lt;p&gt;This post will describe how to make a private CocoaPods for your application.
You will need a private spec repository, letting CocoaPods know where to find it and adding the PodSpecs file to the repo.&lt;/p&gt;

&lt;p&gt;Also, you will need a private repository that stores the source code of your pod library and an example project (if you have).&lt;/p&gt;

&lt;h1 id=&quot;pod-creation&quot;&gt;Pod Creation&lt;/h1&gt;

&lt;p&gt;We use &lt;code&gt;pod lib create YOUR_PROJECT_NAME&lt;/code&gt; command to bootstrap the process.
That will automatic generate an entire project by asking you few questions.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What platform do you want to use? [iOS/macOS] -&amp;gt; iOS&lt;/li&gt;
  &lt;li&gt;What language do you want to use? [Swift/ObjC] -&amp;gt; ObjC&lt;/li&gt;
  &lt;li&gt;Would you like to inculde a demo application with your library? [Yes/No] -&amp;gt; Yes&lt;/li&gt;
  &lt;li&gt;Which testing frameworks will you use? [Specta/Kiwi/None] -&amp;gt; None&lt;/li&gt;
  &lt;li&gt;Would you like to view based testing? [Yes/No] -&amp;gt; No&lt;/li&gt;
  &lt;li&gt;What is your class prefix? -&amp;gt; FF&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;directory-of-the-pod-project&quot;&gt;Directory of the Pod project&lt;/h1&gt;

&lt;p&gt;If you finish the few questions, running &lt;code&gt;pod install&lt;/code&gt; on the example folder.
The basic pod library is born.&lt;/p&gt;

&lt;p&gt;You can add your dependency libraries you need like AFNetworking on Podfile or some static frameworks.&lt;/p&gt;

&lt;p&gt;The folder structure will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TestPro 
├── Example 
│   ├── Podfile 
│   ├── Podfile.lock 
│   ├── Pods 
│   ├── TestPro 
│   ├── TestPro.xcodeproj 
│   ├── TestPro.xcworkspace 
│   └── Tests 
├── LICENSE 
├── README.md 
├── TestPro 
│   ├── Assets 
│   └── Classes 
├── TestPro.podspec 
└── _Pods.xcodeproj -&amp;gt; Example/Pods/Pods.xcodeproj
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;_Pods.xcodeproj: A symlink to your Pod’s project for Carthage support.&lt;/li&gt;
  &lt;li&gt;TestPro.podspec: The PodSpec of your library, you can add some formulas such as spec name, spec version or the path of source files, and so on. You can find more syntax information on Reference section below.&lt;/li&gt;
  &lt;li&gt;Assets &amp;amp; Classes: That contains all .swift/.h/.m files and images you will need.&lt;/li&gt;
  &lt;li&gt;Pods folder: That stores the external pod libaries you need, including a dynamic framework be installed from Podfile or a static framework you added manually.&lt;/li&gt;
  &lt;li&gt;Example folder: That stores the example project using the Pod library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;add-custom-files-as-you-need&quot;&gt;Add custom files as you need&lt;/h1&gt;

&lt;h4 id=&quot;dynamic-frameworks&quot;&gt;Dynamic frameworks&lt;/h4&gt;

&lt;p&gt;You can use some dependency frameworks through Podfile,
for example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39; 

platform :ios, &#39;8.0&#39; 
use_frameworks! 

inhibit_all_warnings! 

target &#39;TestPro_Example&#39; do 

	pod &#39;TestPro&#39;, :path =&amp;gt; &#39;../&#39; 
	pod &#39;AFNetworking&#39; 
	
	target &#39;TestPro_Tests&#39; do 
		inherit! :search_paths 
	end 
	
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then run &lt;code&gt;pod install&lt;/code&gt;, that will fetch the AFNetworking library into the Pods folder.&lt;/p&gt;

&lt;h4 id=&quot;static-frameworks&quot;&gt;Static frameworks&lt;/h4&gt;

&lt;p&gt;If there are no Pod resource support, you can add the library into the Pods folder by manually.&lt;/p&gt;

&lt;p&gt;Then modify the PodSpec file by adding static_framework and dependency.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.static_framework = true 
s.dependency &#39;AliPay_SDK&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then run &lt;code&gt;pod install&lt;/code&gt;, that will generate the AliPay_SDK library dependency on Xcode.&lt;/p&gt;

&lt;h4 id=&quot;wrappers-files&quot;&gt;Wrappers files&lt;/h4&gt;

&lt;p&gt;You can new some wrapper files on Classes folder that will handle those libraries for usage more easier.&lt;/p&gt;

&lt;h1 id=&quot;push-the-pod-source-code&quot;&gt;Push the Pod source code&lt;/h1&gt;

&lt;p&gt;After you finished features development and write some descriptions on README.md file.&lt;/p&gt;

&lt;p&gt;You need to commit and tag a version number, then push the source code to the remote repository.&lt;/p&gt;

&lt;p&gt;We suggest that the tag number should be equal to the PodSpec version number and follow &lt;a href=&quot;https://semver.org/&quot;&gt;Semantic version define&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add . 
git commit -m &#39;First release&#39; 
git tag &#39;1.0.0&#39; 
git push origin master 
git push --tags
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;deploy-the-pod-library&quot;&gt;Deploy the Pod library&lt;/h1&gt;

&lt;p&gt;Using the URL of your private spec repository, adding your repo using:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pod repo add POD_NAME THE_URL_OF_SPEC_REPOSITORY&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Save your PodSpec file and add to the repo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;pod-update&quot;&gt;Pod update&lt;/h1&gt;

&lt;p&gt;Once we modified the Pod library, we need to change the version number on PodSpec file.&lt;/p&gt;

&lt;p&gt;Before you deploy the Pod library, you need to commit, bump up tag version number and push source code to the remote repo under source control.&lt;/p&gt;

&lt;p&gt;If you facing a problem about &lt;code&gt;The TestPro.podspec specification does not validate.&lt;/code&gt; when running &lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can run &lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE --verbose --use-libraries --allow-warnings&lt;/code&gt; to resolve it.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html#specification&quot;&gt;Podspec Syntax Reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/using-pod-lib-create&quot;&gt;Using Pod Lib Create&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/private-cocoapods&quot;&gt;Private Pods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://semver.org/&quot;&gt;Semantic Versioning 2.0.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 15:35:29 +0800</pubDate>
        <link>http://blog.wchuang.me/2018/04/15/how-to-make-a-private-cocoapods/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2018/04/15/how-to-make-a-private-cocoapods/</guid>
        
        
      </item>
    
      <item>
        <title>PresentViewController delay on UITableViewCell</title>
        <description>&lt;p&gt;最近開發常常遇到：當點選 UITableViewCell 時去呼叫 presentViewController:animated:completion:，欲開啟的 view controller 會延遲出現的問題，這個似乎是 iOS 7 的 bug，不過之前開發手機卻沒什麼遇到，直到最近開發 iPad 才發現。&lt;/p&gt;

&lt;p&gt;原因是當 UITableViewCell 的 selectionStyle 設為 UITableViewCellSelectionStyleNone，也就是希望不要出現點選效果時，造成沒有動畫效果去觸發 main runloop，所以 thread 好像是睡著了…&lt;/p&gt;

&lt;p&gt;解決方式：&lt;/p&gt;

&lt;p&gt;在呼叫 presentViewController:animated:completion: 後&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;呼叫 CFRunLoopWakeUp(CFRunLoopGetCurrent())&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 執行一個空的 block：dispatch_async(dispatch_get_main_queue(), ^{})&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 直接呼叫 presentViewController:animated:completion:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From: &lt;a href=&quot;http://stackoverflow.com/questions/21075540/presentviewcontrolleranimatedyes-view-will-not-appear-until-user-taps-again&quot;&gt;Stackoverflow 討論&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot;&gt;Thread run loops&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Nov 2015 02:36:24 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/11/22/presentviewcontroller-delay-on-uitableviewcell/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/11/22/presentviewcontroller-delay-on-uitableviewcell/</guid>
        
        
        <category>ios</category>
        
        <category>uitableview</category>
        
        <category>uitableviewcell</category>
        
      </item>
    
      <item>
        <title>Custom NSLog</title>
        <description>&lt;pre&gt;&lt;code&gt;#ifdef DEBUG
#   define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);
#else
#   define DLog(...)
#endif

#define ALog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);

#ifdef DEBUG
#   define ULog(fmt, ...)  { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;%s\n [Line %d] &quot;, __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:fmt, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; }
#else
#   define ULog(...)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入以上的 code 到 .pch 檔。&lt;/p&gt;

&lt;p&gt;這邊定義了三種不同的 log 方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DLog：相當於 NSLog，但它只有在 DEBUG 模式中才可以被使用。相較於 NSLog，自訂的 function 名稱及程式碼行數也會印出來。&lt;/li&gt;
  &lt;li&gt;ALog：等同 NSLog，function 名稱及程式碼行數也會印出來。&lt;/li&gt;
  &lt;li&gt;ULog：等於用 UIAlertView 印出 DLog。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 14 Oct 2015 01:21:14 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/10/14/custom-nslog/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/10/14/custom-nslog/</guid>
        
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>Distribute an iOS application OTA</title>
        <description>&lt;p&gt;簡單記錄如何建立給外部使用者或客戶測試的 AdHoc 版本&lt;/p&gt;

&lt;p&gt;iOS app OTA (over the air)，&lt;/p&gt;

&lt;p&gt;而如何產生憑證及 archive 出 AdHoc 就不再贅述了，網路也有很多資源。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重要的是描述下載位置的 HTML、描述 app 的 plist 檔案以及 app 的 .ipa 檔案，找台伺服器來存放它們吧！這邊推薦使用 Dropbox 方便又好用，當然你也可以用自家 server 或其它 web storage services。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;.ipa 檔：AdHoc 出 .ipa 檔案，並上傳到 Dropbox 底下，點選分享後，會拿到一個分享連結，如 https://www.dropbox.com/s/ooxxaabbcc/ForTestingApp.ipa?dl=0 ，把 www.dropbox.com 改成 dl.dropboxusercontent.com 及 ?dl=0 拿掉，會變成 -&amp;gt; https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.ipa 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;plist 檔：加入一個 Array 的 key，名稱取為 assets，負責描述 .ipa、app icon 兩張（57 * 57）及 (512 * 512) 的分享連結路徑 (與上述 .ipa 檔案ㄧ樣，需放在 dropbox 中，並開啟分享取得連結)，如果不放圖片的話，下載中就看不到 app 的 icon 囉。再加入一個 Dictionary 的 key，名稱取為 metadata，描述 app 相關資訊，如 bundle-identifier、title 或 subtitle 等等。最後一樣開啟分享取得連結。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML 檔：最後是 HTML，拿來記錄上述 plist 檔的分享位置，並做個畫面呈現給使用者點選下載，可以簡單放上下列程式。&lt;/p&gt;

 	&lt;a href=&quot;itms-services://?action=download-manifest&amp;amp;url=  	https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.plist&quot;&gt;
 	Install this awesome app!&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成後你就可以把 HTML 的連結給你的朋友或客戶測試囉，不過要記得把手機的 UDID 加進去 Provisioning Profile。&lt;/p&gt;

&lt;p&gt;以上，有不清楚的地方歡迎指教 :p&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Apr 2015 00:53:56 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/04/08/distribute-an-ios-application-ota/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/04/08/distribute-an-ios-application-ota/</guid>
        
        
        <category>ios</category>
        
        <category>ota</category>
        
        <category>adhoc</category>
        
        <category>distribute</category>
        
      </item>
    
      <item>
        <title>[UIView viewWithTag:]</title>
        <description>&lt;p&gt;這篇關於使用 [UIView viewWithTag:] 的文章，雖然已是兩年前的，但在下認為文章內所提及的觀念與用法還是很值得與大家分享。&lt;/p&gt;

&lt;p&gt;UIView 有個 tag 屬性以及相對應的方法 -viewWithTag:，讓我們可以輕易的存取特定的 view，而不需要額外的 reference。&lt;/p&gt;

&lt;p&gt;這邊作者分享了幾個使用上常見的問題：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不要使用 tags 來儲存資料，例如：陣列存取物件的索引 (index)…，因為這是一件容易造成後續維護者難以理解你的 code 的一件事…底下是一個使用 button 來呈現圖片縮圖的例子，為了記得哪個按鈕被按到以及要呈現哪個對應於 array 中的圖片索引，所以利用 tag 來記錄。~~(但其實還滿容易這麼幹的啊…在下也常這麼做，要好好檢討了orz)~~&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  - (void)configureThumbnailButton:(UIButton *)thumbnailButton 
                          forPhoto:(NSUInteger)photoIndex {
  		// ...
  	thumbnailButton.tag = 1 + photoIndex;
  		// ...
  }

  - (void)thumbnailButtonTapped:(id)sender {
  		UIButton *thumbnailButton = sender;
  		NSUInteger photoIndex = thumbnailButton.tag - 1;
  		id selectedPhoto = [self.photoArray objectAtIndex:photoIndex];
  		[self showPhoto:selectedPhoto];
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存取 view 額外資料的幾個比較正確的方式：&lt;/p&gt;

    &lt;p&gt;我們來探討一下為什麼會寫出上述例子的程式碼，其實也只是想要知道 button 對應的 index，或是 button 真正對應的圖片縮圖，此時更適合的方式應該是另外做一個 custom subClass 來儲存這些有用的額外資料，延續上述例子，應該可以這麼做：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  @interface PhotoThumbnailButton : UIButton

  @property (nonatomic, assign) NSInteger photoIndex;
  // OR
  @property (nonatomic, strong) Photo *photo;

  @end
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;這時候你會說，如果每次都要這樣也太麻煩了吧！的確，每次都要建個 subClass 有時可能不符合實際情況，底下也提供一個用法：Associated references。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://goo.gl/6fM6Kq&quot;&gt;Associated references&lt;/a&gt;：提供了 objc_getAssociatedObject 以及 objc_setAssociatedObject 等方法，可以利用特定的 key 及 policy 存取特定的 obejct。如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #import &amp;lt;objc/runtime.h&amp;gt;

  static char kThumbnailButtonAssociatedPhotoKey;

  // ...

  - (void)setAssociatedPhoto:(Photo *)associatedPhoto
          forThumbnailButton:(UIButton *)thumbnailButton {
  		objc_setAssociatedObject(thumbnailButton,
  		                         &amp;amp;kThumbnailButtonAssociatedPhotoKey,
                               associatedPhoto,
                               OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  }

  - (Photo *)associatedPhotoForThumbnailButton:(UIButton *)thumbnailButton {
      return objc_getAssociatedObject(thumbnailButton,
                              		 &amp;amp;kThumbnailButtonAssociatedPhotoKey);
  }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;存取時，&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;	- (void)configureThumbnailButtonForPhoto:(Photo *)photo {
  		// ...
  		[self setAssociatedPhoto:photo forThumbnailButton:thumbnailButton];
  		// ...
  }

  - (void)thumbnailButtonTapped {
  		Photo *photo = [self associatedPhotoForThumbnailButton:thumbnailButton];
  		// ...
  }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;真的是很酷啊… 可是，如果只是想要快速直接的知道是哪一個 view，這樣的方式還是不夠直覺…所以，有些情況下，你還是會想直接利用 UIView’s tag 存取，但重點是請遵循 UIView’s tag 是 UIView 的唯一識別、可讀性以及易維護性的觀念，而使用 #define 或 enum value 來設定 tags，在你之後的開發者會很感謝你的..XD，例如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  enum MyViewTags {
      kTitleLabelTag = 1,
  		kSendButtonTag,
  		kSomeOtherViewTag
  };

  // ...

  if (sender.tag == kSendButtonTag) {
  		// ...
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;結論：
    &lt;ul&gt;
      &lt;li&gt;不要使用 tags 來儲存資料 -&amp;gt; use sub-class or associated references resolving this.&lt;/li&gt;
      &lt;li&gt;多利用 public properties of sub-class for getting references of subviews.&lt;/li&gt;
      &lt;li&gt;If you do use tags, do not use magic numbers. Use named constants.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://goo.gl/0xHqWt&quot;&gt;Ref.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 11 Nov 2014 01:46:01 +0800</pubDate>
        <link>http://blog.wchuang.me/2014/11/11/uiview-viewwithtag/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2014/11/11/uiview-viewwithtag/</guid>
        
        
        <category>viewwithtag</category>
        
        <category>uiview</category>
        
        <category>objective-c</category>
        
        <category>ios</category>
        
        <category>uikit</category>
        
      </item>
    
  </channel>
</rss>
