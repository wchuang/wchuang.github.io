<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frank's blog - Developer, coffee lover and traveler</title>
    <description>iOS development sharing, Swift, Objective-C</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 20 Jun 2021 00:57:07 +0800</pubDate>
    <lastBuildDate>Sun, 20 Jun 2021 00:57:07 +0800</lastBuildDate>
    <generator>Jekyll v3.8.7</generator>
    
      <item>
        <title>强大的 Network Instruments - 诊断你的 APP 网络请求及流量控管</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/session_10212_banner.png&quot; alt=&quot;session_10212_banner&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;WWDC21 - Session10212 - &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2021/10212/&quot;&gt;Analyze HTTP traffic in Instruments&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;强大的-network-instruments---诊断你的-app-网络请求及流量控管&quot;&gt;强大的 Network Instruments - 诊断你的 APP 网络请求及流量控管&lt;/h1&gt;

&lt;h2 id=&quot;contents&quot;&gt;Contents&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;前言&lt;/li&gt;
  &lt;li&gt;Xcode 13 Beta Release Notes&lt;/li&gt;
  &lt;li&gt;Instruments with Network template
    &lt;ul&gt;
      &lt;li&gt;新版本视图&lt;/li&gt;
      &lt;li&gt;新版本特点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;做了哪些优化
    &lt;ul&gt;
      &lt;li&gt;网络追踪视图层级调整&lt;/li&gt;
      &lt;li&gt;Task 及 Transaction 概念&lt;/li&gt;
      &lt;li&gt;请求的几种标签&lt;/li&gt;
      &lt;li&gt;请求的几种状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何检测你的网络请求并且解决问题
    &lt;ul&gt;
      &lt;li&gt;发现第一个问题&lt;/li&gt;
      &lt;li&gt;开启 Instruments&lt;/li&gt;
      &lt;li&gt;APP 启动&lt;/li&gt;
      &lt;li&gt;检测问题并修复&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;集成共享登录 Pets SDK
    &lt;ul&gt;
      &lt;li&gt;验证 Sign In with Pets&lt;/li&gt;
      &lt;li&gt;发现隐私泄漏&lt;/li&gt;
      &lt;li&gt;如何导出 Trace 日志&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;更进一步&lt;/li&gt;
  &lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;今年 WWDC 2021 苹果除了推出了期待已久的 async/await, actors 等的 concurrency 相关技术外，也在性能优化上下了许多努力，如：&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2021/10239&quot;&gt;Reduce network delays for your app&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2021/10180/&quot;&gt;Detect and diagnose memory issues&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2021/10258/&quot;&gt;Understand and eliminate hangs from your app&lt;/a&gt; 等，有网络，内存或卡顿相关主题。&lt;/p&gt;

&lt;p&gt;而苹果内置的性能检测工具 Instruments 也在今年针对网络监控上做了大大的升级，这也是今天要介绍的主题：如何使用 Instruments 检测并且分析你的 app 网络流量及 HTTP 请求行为。&lt;/p&gt;

&lt;p&gt;Let’s get it started!&lt;/p&gt;

&lt;h2 id=&quot;xcode-13-beta-release-notes&quot;&gt;Xcode 13 Beta Release Notes&lt;/h2&gt;

&lt;p&gt;先来看一下这次的 Release Notes，这边只列出与 Instruments 相关的，感兴趣的同学可以看下 &lt;a href=&quot;https://developer.apple.com/documentation/xcode-release-notes/xcode-13-beta-release-notes&quot;&gt;Xcode 13 Beta Release Notes&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;New features
    &lt;ul&gt;
      &lt;li&gt;可以调适进程 CFNetwork 层的 HTTP 流量，包括了进程外后台流量&lt;/li&gt;
      &lt;li&gt;可以看到基于每个 URLSessionTask 的耗时、HTTP transaction 及 transaction 详细状态&lt;/li&gt;
      &lt;li&gt;可以看到 URLSessionTask 的 Backtraces 调用栈，也能定位到代码具体位置&lt;/li&gt;
      &lt;li&gt;完整的 HTTP 请求及响应的 headers 及 bodies&lt;/li&gt;
      &lt;li&gt;可以获取到经由 VPN、proxies 或者绑定证书发送的流量&lt;/li&gt;
      &lt;li&gt;支持使用新的 –har 导出标志，经由 xctrace 导出 HTTP 数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Known Issues
    &lt;ul&gt;
      &lt;li&gt;使用 tvOS 15 系统的 Apple TV，无法停止 Instruments 发起的 HTTP 流量记录
  	- Workaround：不用 Instruments 记录 HTTP 流量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：想要尝鲜的同学需要先升级到 iOS 15，同时模拟器是不支持的。&lt;/p&gt;

&lt;h2 id=&quot;instruments-with-network-template&quot;&gt;Instruments with Network template&lt;/h2&gt;

&lt;h3 id=&quot;新版本视图&quot;&gt;新版本视图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-13-whole.png&quot; alt=&quot;instrument_13_whole&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;新版本特点&quot;&gt;新版本特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;可适用于所有苹果设备。&lt;/li&gt;
  &lt;li&gt;支持 HTTP/3 以及 VPN。&lt;/li&gt;
  &lt;li&gt;进程为单位，集成于底层网络框架：可以让你在使用 high level 的 NSURLSession 及 NSURLSessionTask 时，监控网络请求整个链路情况，包含命中缓存请求或是网络错误。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;做了哪些优化&quot;&gt;做了哪些优化&lt;/h2&gt;

&lt;h3 id=&quot;网络追踪视图层级调整&quot;&gt;网络追踪视图层级调整&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;最上层的 HTTP Tracffic 记录了你的 app 整个生命周期内有几个 URLSession tasks。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-13-top.png&quot; alt=&quot;instrument_13_top&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;次层以 Process 进程作为区别，在每个进程底下你可以看到都有几个 URLSession 进行著，你也可以看到 URLSession 做了哪些任务。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-13-middle1.png&quot; alt=&quot;instrument_13_middle_1&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-13-middle2.png&quot; alt=&quot;instrument_13_middle_2&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;另外，你可以对每个 URLSession 命名，如：这边的 Main Session。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; let session = URLSession(configuration: .default)
 session.sessionDescription = &quot;Main Session&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最下层是以每个请求的 Domain 域名作为区隔，你可以看到每个请求的状态，包含它的请求方法，响应时间，成功或者失败等等。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-13-bottom.png&quot; alt=&quot;instrument_13_bottom&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;task-及-transaction-概念&quot;&gt;Task 及 Transaction 概念&lt;/h3&gt;

&lt;p&gt;这里引入了 Task 以及 Transaction 的概念，一个 task 可以包括了许多 transactions，你可以想像每个 transaction 就是一个请求，它是由 request + response 组成，也就是请求发起直到收到响应为主。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let task = session.dataTask(with: url) { data, response, error in
	// Task end!
}

task.resume() // Task start!
task.taskDescription = &quot;Load Thumbnail&quot;
task.taskIdentifier = 42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们調用了 resume 方法，表示 task 開始，直到收到 API response 回调後，task 结束。你可以替每个 task 命名以及编号，它方便我们在 instruments 上区分。&lt;/p&gt;

&lt;p&gt;比如：
	&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-transaction-success.png&quot; alt=&quot;transaction_success&quot; /&gt;
如果请求失败（自动带入错误信息，方便调适）：
	&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-transaction-failure.png&quot; alt=&quot;transaction_failure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上述提到的，一个 task 可以包含多个 transactions，假设我们发送一个 GET 请求到 apple.com，但这个网址不是一个标准的 URL 格式，因为实际上 domain 位置是在 www.apple.com。所以当我们建立了这样的一个任务时，URL loading system 会建立一个发送到 apple.com 的请求，随即收到由服务器返回的转址响应，然后转址至 www.apple.com。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-multi-transactions.png&quot; alt=&quot;multi_transactions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同时，在第一个 transaction 你可以看到后面跟著 301 的 HTTP 状态码，也是意味著收到了一个redirect 转址回应。而第二个 transaction 则是收到了 200 状态码的成功响应。所以，一个 transaction 由一组 HTTP 请求及响应组成，它跟 URLSession 处理任务的方式一致，并且包含了 HTTP 层的所有信息，比如：请求的 URL、传输的数据信息等等。&lt;/p&gt;

&lt;p&gt;底下小总结一下，一个请求 (transaction) 都有哪些标签。&lt;/p&gt;

&lt;h3 id=&quot;请求的几种标签&quot;&gt;请求的几种标签&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-transaction-labels.jpeg&quot; alt=&quot;transactions_labels&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;请求的几种状态&quot;&gt;请求的几种状态&lt;/h3&gt;

&lt;p&gt;每次请求由 request 发起到接收 response 的耗时
首先我们需要先了解请求的几种状态及其变化。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-transaction-state.jpeg&quot; alt=&quot;transactions_state&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;缓存查找&quot;&gt;缓存查找&lt;/h4&gt;

&lt;p&gt;请求的开始是由 URL Loading System 发出请求的时间，也就是调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume&lt;/code&gt; 的时候，接著，开始检查是否存在一个有效的缓存响应？如果没有，则开始请求的排程。&lt;/p&gt;

&lt;h4 id=&quot;阻塞&quot;&gt;阻塞&lt;/h4&gt;

&lt;p&gt;这个阶段可能处于等待连线的建立或是连线忙碌中，直到可用的连线资源释出。&lt;/p&gt;

&lt;h4 id=&quot;发出请求&quot;&gt;发出请求&lt;/h4&gt;

&lt;p&gt;当可用连线资源释出并且完成连线建立，就会发出请求。从第一个字节发出起算，直到最后一个字节发出为止。&lt;/p&gt;

&lt;h4 id=&quot;等待响应&quot;&gt;等待响应&lt;/h4&gt;

&lt;p&gt;闲置状态，等待服务端响应。&lt;/p&gt;

&lt;h4 id=&quot;接收响应&quot;&gt;接收响应&lt;/h4&gt;

&lt;p&gt;收到服务端响应，由收到第一个字节起算，直到接收最后一个字节为止。一旦 URL Loading System 确定这是一个成功的响应，整个请求在最后一个字节后立即完成。&lt;/p&gt;

&lt;p&gt;实务上来说，GET 的缓存查找阶段以及发送请求状态通常要短很多，因此，更可能出现这样的情况，简化为三个阶段：阻塞、等待响应以及接收响应。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-transaction-state-get.png&quot; alt=&quot;transactions_state_of_GET&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;如何检测你的网络请求并且解决问题&quot;&gt;如何检测你的网络请求并且解决问题&lt;/h2&gt;

&lt;p&gt;接下来我们藉由一个实际的 APP 操作，了解如何利用 HTTP Instrument 检测你的网络请求，并且了解如何修复问题及提升效能。&lt;/p&gt;

&lt;p&gt;&amp;lt;div align=center/&amp;gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-dogs-demo.png&quot; alt=&quot;instrument-dogs-demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个 demo APP 是一个给喜爱狗狗的目标族群使用，用户可以分享上传爱狗的照片到平台上，你也可以看到你最近上传的图像。&lt;/p&gt;

&lt;h3 id=&quot;发现第一个问题&quot;&gt;发现第一个问题&lt;/h3&gt;
&lt;p&gt;所以当你每次打开 APP 的时候，APP 会加载新的几张狗狗图像，但是面临到一个问题：&lt;em&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;这些图像需要一段很长时间才能完成加载&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;让我们用 HTTP Traffic instrument 来帮助我们优化这个问题吧！&lt;/p&gt;

&lt;h3 id=&quot;开启-instruments&quot;&gt;开启 Instruments&lt;/h3&gt;

&lt;p&gt;在 Xcode 上 Product menu 选择 Profile，Profile 会以 release 配置编译我们的 APP，确保我们是在开启全部优化的状态下运行。编译完成后，Instruments 会自动打开，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-network.png&quot; alt=&quot;instrument_network_template&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们选择 Network template，它会展示 APP 里所有的网络活动，也包含了这次新增加的 HTTP 追踪功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-tracks.png&quot; alt=&quot;instrument_network_tracks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Instrument 打开后，你会看到两个追踪轨，第一个是 HTTP Traffic，也是我们这次推出的新功能，我们关注这个轨道。接著，点击 &lt;em&gt;record&lt;/em&gt; 开始检测。&lt;/p&gt;

&lt;p&gt;在你刚开始使用这个功能的时候，你需要先同意隐私权政策，因为 Instrument 会记录所有的网络行为，里面可能会涉及到个人隐私相关的信息及敏感数据，所以你必须要先同意并且小心的使用这些数据。&lt;/p&gt;

&lt;h3 id=&quot;app-启动&quot;&gt;APP 启动&lt;/h3&gt;

&lt;p&gt;开始录制后，Instrument 会自动启动你的 APP，如我们所预期的，APP 打开后以很缓慢的速度下载这些狗狗图像。我们停止录制，来看看发生了什么问题吧！&lt;/p&gt;

&lt;h3 id=&quot;检测问题并修复&quot;&gt;检测问题并修复&lt;/h3&gt;

&lt;p&gt;把 HTTP Traffic 展开后，你可以看到我们的 Dogs! APP，以及使用的 Main Session URLSession，以及这次载入图像请求的 dogs.example 域名。我们选择这个域名，可以看到详细的请求信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track1.png&quot; alt=&quot;instrument_track1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到第一个任务是向服务端 GET 查询所有的图像列表，这些图像会出现在 APP 的 “Latest” Tab。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track2.png&quot; alt=&quot;instrument_track2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当这个任务完成后，我们会创建新的任务去载入列表上每张图像的缩略图以展示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track3.png&quot; alt=&quot;instrument_track3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总的来说，我们大概需要超过七秒的时候，才能完成全部图像的加载&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track4.png&quot; alt=&quot;instrument_track4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前面几张图片加载的很快，但当我们往下滑动时，会发现接下来的任务需要更长的时间才能完成。证如我们看到的，紫色区域的阻塞状态不断扩大，因为我们有太多的并行请求导致阻塞的问题。&lt;/p&gt;

&lt;h4 id=&quot;为何阻塞&quot;&gt;为何阻塞？&lt;/h4&gt;

&lt;p&gt;为了帮助我们了解为何发生阻塞，我们需要切换到 &lt;em&gt;HTTP Transactions by Connection&lt;/em&gt; 展示。&lt;/p&gt;

&lt;p&gt;在左侧 track 侧边栏中，域名下方有一个向下的箭头，我们可以点击切换到 &lt;em&gt;HTTP Transactions by Connection&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track5.png&quot; alt=&quot;instrument_track5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个模式下只会展示所有的 transactions，而不是对每个任务分组。现在我们就可以知道这些请求被放在哪些连接中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track6.png&quot; alt=&quot;instrument_track6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总的来说，总共有六个连接用来处理这些 transactions。让我们来分析一下，第一个连接发出的请求（transaction）然后进一步看下后续的缩略图加载请求。从上到下，很明显每次请求都需要更长的时间才能完成。每个请求的阻塞区域都在增加，事实上，这里有一个很清晰的 staircase pattern 階梯模式。&lt;/p&gt;

&lt;p&gt;每个请求都被阻塞，直到同一个连接的上一个请求完成，然后才能发送下一则请求。这个模式不断的重演，其实这就是 &lt;em&gt;Head of Line Blocking&lt;/em&gt; 头部阻塞，是一个使用 HTTP/1 版本请求的典型问题之一。&lt;/p&gt;

&lt;p&gt;这些请求在大部分的时间下都没有做任何事情，而是一直处在阻塞或是等待响应的状态。我们其实可以在等待同一个连接的上一个请求响应回来之前，发送下一个请求，但是 HTTP/1 不支持这么做。HTTP/2 主要的改进之一，就是把发送到同一服务器的多个请求，在同一个连接的基础上复用，也就是俗称的多路复用，来避免这样的阻塞情况。&lt;/p&gt;

&lt;h4 id=&quot;http2-多路复用&quot;&gt;HTTP/2 多路复用&lt;/h4&gt;

&lt;p&gt;在 HTTP/2，我们可以在第一个请求等待响应的同时发送第二个请求，你的 APP 完全不用做任何事情来支持，因为所有 Apple 平台都支持 HTTP/2，而且从 iOS 15 和 macOS Monterey 开始，也已经开始支持 HTTP/3。&lt;/p&gt;

&lt;p&gt;如果你想更多了解 HTTP/1 以及 HTTP/2 之间的差异，以及 HTTP/3 提供的其他好处，请观看这个议程 &lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2021/10094&quot;&gt;Accelerate networking with HTTP/3 and QUIC&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在回到我们的 demo APP，改用了 HTTP/2 图像加载瞬间快了好多，it’s amazing！我们来看一下Instrument 上的表现吧！都是绿色了！赞赞！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track7.png&quot; alt=&quot;instrument_track7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们再切换到 &lt;em&gt;HTTP Transactions by Connection&lt;/em&gt;。我们注意这里只有一个连接，这是因为我们不再需要多个连接来发送多个请求，这也意味著我们只需要负担一次连接创建的成本（三次握手）。关注下每个缩略图的请求，我们发现基本上没有处于阻塞的情况，事实上，由于时间非常的短暂，所以在我们的视图缩放级别是看不出来的。最终所有的请求都发出了请求并且等待响应到来，我们往下滚动，可以看到所有的响应都在同一时间收到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track8.png&quot; alt=&quot;instrument_track8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总而言之，我们在 3 秒内完成了所有的请求，这比之前快了两倍！&lt;/p&gt;

&lt;h4 id=&quot;换个场景&quot;&gt;换个场景&lt;/h4&gt;

&lt;p&gt;当我们点击了某一个狗狗图像，会进入一个狗狗的详细页面，这个页面会展示高分辨率的图片并显示离我有多远，右上角还有一个心型图标，可以让你收藏这只狗狗。我允许用户在没有登入的情况下使用 APP 并浏览这些狗狗图片，但是如果想要保存喜爱的图像、在不同设备间同步以及上传新图片，你需要一个帐号登入才能使用。&lt;/p&gt;

&lt;p&gt;| &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track9.png&quot; alt=&quot;instrument_track9&quot; /&gt; | &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track10.png&quot; alt=&quot;instrument_track10&quot; /&gt; |
| :—–| —-: |&lt;/p&gt;

&lt;p&gt;我刚刚收藏了一个狗狗图像并且登录了，让我们再收藏其他狗狗，什么！怎么还需要我重新登录呢？这里我们遇到了第二个问题：&lt;em&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APP 没有记录登录信息&lt;/code&gt;&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;来看看 Instrument 发生了什么事吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track11.png&quot; alt=&quot;instrument_track11&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在最左侧的任务是我第一次按下收藏按钮的时候。&lt;/li&gt;
  &lt;li&gt;在它的右侧是返回到 Latest 页面后发出的任务，并且刷新了图像流。&lt;/li&gt;
  &lt;li&gt;接著，是我点击另一张狗狗图像并且加载高分辨率图像。&lt;/li&gt;
  &lt;li&gt;在最右边，是我第二次点击收藏的任务。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个任务实际上包含了两个请求，第一个请求收到了 401 HTTP 状态码，这是我们预期的，因为这时候我们还没登录。这个请求被绘制成橘色，表示发生了 HTTP 层级错误。然后任务间有一个很大的空白区域，这时候是我们在输入帐号密码所花费的时间。当我输入完成后，就会重新发起请求，这时候收到了 201 HTTP 状态码并且显示为绿色，表示收藏成功。&lt;/p&gt;

&lt;p&gt;这里的身分验证、输入密码以及请求重试是 URL Loading System 替我们处理的，因此这两次请求属于同一个任务对象。&lt;/p&gt;

&lt;h4 id=&quot;过期的-cookie&quot;&gt;过期的 Cookie&lt;/h4&gt;

&lt;p&gt;第二次点击收藏的时候，任务对象显示为灰色，这是因为我认为第一次已经登录过了，所以直接关闭登录页面而导致任务被取消，这能在标签中看出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track12.png&quot; alt=&quot;instrument_track12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;请求的间隔是橘色的，因为我们再次从服务端收到了 401 HTTP 状态码，此任务发生在当我尝试把另一只狗狗添加到收藏并再次提示登录后。我们使用一个非常基本的登入系统，用户第一次发送他们的凭证后，一旦服务端收到了并且验证通过，它就会设置一个 cookie 来识别这个用户，这样就不需要在之后的请求再次验证，所以我希望 cookie 有正确的被设置成功。&lt;/p&gt;

&lt;p&gt;如同之前提到过的，如果请求发送了 cookie 标头，那么在 HTTP 方法旁边应该要有一个小 cookie 图标。但这里却没有这样的图标，这意味著没有发送 cookie。那么现在的问题是，服务端没有为我们提供 cookie，或是客户端没有发送 cookie 呢？&lt;/p&gt;

&lt;p&gt;为了找出答案，我们需要调查之前的请求并检查我们是否从服务端获得了 cookie。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track13.png&quot; alt=&quot;instrument_track13&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是第一个登录请求的成功请求，我们可以看到在服务端响应的地方确实有一个 cookie 图标，这表示服务端确实发送了一个 cookie。那为什么我们不在下一次的请求中发送 cookie 呢？要获取有关这个请求的更多信息并详细调查 cookie，我们把底部详细信息切换到 “Transactions” 列表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track14.png&quot; alt=&quot;instrument_track14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track15.png&quot; alt=&quot;instrument_track15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;右边显示了当前选定请求的的所有请求以及响应表头，这是我们期望的 Set-Cookie 表头。但是你有发现一个问题吗？上面的有效期是 2020 年 3 月，那已经过去了！所以服务端确实发送了一个 cookie，但它是一个过期的 cookie。这将导致 URLSession 不发送 cookie，因为 URLSession 只会发送仍然有效的 cookie。&lt;/p&gt;

&lt;p&gt;这是服务端的一个 bug，一会儿我把 trace 文件发给我们服务端同学，让他们调查问题并修复。现在我们解决了 cookie 问题，我可以收藏更多图片而不需要一直提示登录了！&lt;/p&gt;

&lt;h4 id=&quot;没有展示的收藏&quot;&gt;没有展示的收藏&lt;/h4&gt;

&lt;p&gt;除了 Latest Tab 之外，APP 还有一个 Favorite Tab，我们可以在里面显示所有用户已经收藏的
狗狗图片，让我们切换到这个 Tab 吧。&lt;/p&gt;

&lt;p&gt;这里有一些我昨天添加过的收藏，但由于某种原因，我&lt;em&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;最近收藏的狗狗没有展示出来&lt;/code&gt;&lt;/em&gt;，让我们用 Instrument 来看看发生什么问题吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track16.png&quot; alt=&quot;instrument_track16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;底下列表有很多请求，我可以用左下角的过滤器來搜索与 “Favorites” 相关的请求，这样我们就能验证是否发出了请求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track17.png&quot; alt=&quot;instrument_track17&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过滤后，结果显示我们发送了多个请求，让我们检查每个请求，并且关注在 track view 上面，假如请求时间很短暂的话，你可以放大检视。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track18.png&quot; alt=&quot;instrument_track18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是我们的第一个请求，它是我们第一次进入我的收藏获取的收藏列表请求，看起来没什么问题。我们接著再看其他请求：第二个请求，我收藏了一个新图片，第三个请求，我们再次加载了收藏列表，但是这个 GET  请求只花了几毫秒，这太快了，以致于无法获得服务端响应。让我们切换到 &lt;em&gt;HTTP Transactions by Connection&lt;/em&gt; 来看更多信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track19.png&quot; alt=&quot;instrument_track18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们注意到第一件事是这个请求不在连接中执行，而是在 &lt;em&gt;Local Cache&lt;/em&gt; 执行。这表示这个请求没有在网络上发送，而是在本地缓存中加载。这也解释了为什么没有等待响应的状态，因为请求没有发送到服务端。&lt;/p&gt;

&lt;p&gt;所以这就是问题所在：我们的请求被缓存了！所以我们实际上并没有询问服务端，并且总是得到一个缓存的响应。&lt;/p&gt;

&lt;h4 id=&quot;如何解决-local-cache&quot;&gt;如何解决 Local-Cache&lt;/h4&gt;

&lt;p&gt;想要解决这个问题的一种方式是设置 &lt;em&gt;cache-control&lt;/em&gt; 表头并告诉服务端不要缓存这个响应。我们想要用户每次打开我的收藏 Tab 都能加载到最新收藏的图片。如果没有最新收藏的图片，也就是收藏列表没有变化，我们就不需要重复加载整个列表。所以，如果我们可以询问服务端：”Hey，有什么变化吗？” 如果有，让我知道。这实际上是我们可以通过在请求上设置缓存策略来实现的！&lt;/p&gt;

&lt;h4 id=&quot;利用-instrument-修改代码&quot;&gt;利用 Instrument 修改代码&lt;/h4&gt;

&lt;p&gt;| &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track20.png&quot; alt=&quot;instrument_track20&quot; /&gt; | &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track21.png&quot; alt=&quot;instrument_track21&quot; /&gt; |
| :—–| —-: |&lt;/p&gt;

&lt;p&gt;我们可以在右侧看到 URLSession 中每个任务的 backtrace 查看方法调用栈，其中在任务中调用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resume&lt;/code&gt;，它在 ImageCollection 类型的方法被同步调用。让我们打开 Xcode 修改它。（笔者：这里如果可以支持直接关连到 Xcode 就更方便了）&lt;/p&gt;

&lt;h4 id=&quot;增加缓存策略&quot;&gt;增加缓存策略&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track22.png&quot; alt=&quot;instrument_track22&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在 URLRequest 增加了缓存策略：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.reloadRevalidatingCacheData&lt;/code&gt;，这表示我们每次请求都会忽略本地缓存，每次都像服务端发出请求，并且验证我们的缓存是否仍然有效，如果仍然有效的话，服务端将发送 304 响应，让我们继续使用本地缓存。如果失效，服务端将返回最新数据。我们再试试看这样的修改能成功吗？太好了，当我们每次开启收藏夹都能看到我最新添加的狗狗图片了！&lt;/p&gt;

&lt;h2 id=&quot;集成共享登录-pets-sdk&quot;&gt;集成共享登录 Pets SDK&lt;/h2&gt;

&lt;p&gt;现在我们已经有 Sign In with Apple 登录选项，但我们公司也有几个宠物主题的 APP，另外一个团队正在开发一个共享登录的 SDK 组件，让用户可以在不同 APP 中重复使用他们的帐号。由于这个 SDK 组件还在开发中，另外一个团队询问我们可否用他们的 Pets 代替，所以我拿到了一个二进制 Pets 的 .xcframework 包，方便跨平台使用。现在我们把 Pets 集成到我们的 APP 中，并在 Sign In with Apple 底下添加一个 Sign In with Pets 登录按钮。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track23.png&quot; alt=&quot;instrument_track23&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;验证-sign-in-with-pets&quot;&gt;验证 Sign In with Pets&lt;/h3&gt;

&lt;p&gt;现在我想知道这种登录方法有多快。我们一样使用 Instruments 来分析。&lt;/p&gt;

&lt;p&gt;现在我的 APP 已经启动，并且切换到登录视图。Instruments 显示了这段期间发生的所有网络流量，让我们关注在我们 APP 的 URLSession，但是等等，我预期这边只有出现我们主程序的 URLSession，但是我们刚刚集成的 Pets framework 也从它自己的 URLSession 发出请求，我甚至都没有点击登录按钮。这不是我们所预期的，让我们停止录制来看看发生了什么事吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track24.png&quot; alt=&quot;instrument_track24&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;发现隐私泄漏&quot;&gt;发现隐私泄漏&lt;/h3&gt;

&lt;p&gt;我们放大最初的几个请求，发现有很多相关的 endpoints，要获取更详细的信息，我们点击 “Pets Sign On Network” session，并在底下详细视图中列出所有请求。它们都是 POST 请求，当我点击某一个请求时，右侧的 backtrace 可以看出请求源自代码的哪一部分。&lt;/p&gt;

&lt;p&gt;因此，如我们所欲其请求经由 Pets 调用的 CFNetwork，但我们更深层的查看后，发现似乎涉及到 CoreLocation，这真的很可疑！尤其是当我没有执行任何的操作的时候触发。&lt;/p&gt;

&lt;p&gt;我猜测我的位置被发送到了服务端，这也就是 CoreLocation 以及 CFNetwork 在同一个 backtrace 的原因。&lt;/p&gt;

&lt;p&gt;| &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track25.png&quot; alt=&quot;instrument_track25&quot; /&gt; | &lt;img src=&quot;https://gitee.com/franklol/session_10212_images/raw/master/wwdc-instrument-track26.png&quot; alt=&quot;instrument_track26&quot; /&gt; |
| :—–| —-: |&lt;/p&gt;

&lt;p&gt;为了验证这个问题，我需要通过检查任务中具体请求的详细信息，所以我把详细信息由任务列表切换到请求列表。在右下角的扩展细节中，你可以看到请求包含一些非常标准的表头，这不用担心，但是等等，看了一下请求的 body，我发现它包含了我的位置座标，这真的很糟糕！发送此信息就侵犯了用户的隐私，我们不想在未经他们同意且没有充分理由的情况下收集他们的位置。&lt;/p&gt;

&lt;p&gt;到目前为止，为了让用户体验更加良好，我们的 APP 只允许出于合法的目的请求此权限。所以，我不会进一步讨论这个 SDK 的集成，相反的，我会向其他团队提交错误报告，告知他们我检测到这种不可接受的行为。我可以利用 Instruments trace 产生必要的信息错误报告。&lt;/p&gt;

&lt;h3 id=&quot;如何导出-trace-日志&quot;&gt;如何导出 Trace 日志&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;可以利用 Instrument 直接储存&lt;/li&gt;
  &lt;li&gt;利用 xctrace command line 导出&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;xctrace 是一个内置在 Instruments 的命令行工具，它可以 trace 数据导出为 HTTP 存档格式，这是用于交换有关 HTTP 流量信息的行业标准。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xctrace export --input YOUR_FILE_NAME.trace --har&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个命令行可以导出 .har 的错误报告文件，收到的人可以在任一支持 HAR 的工具检视信息，即便他们的机器上没有安装 Instruments。&lt;/p&gt;

&lt;p&gt;HAR 本身是一种基于 JSON 的格式，所以它也可以在文本编辑器或是使用脚本打开。虽然它里面不包含 Instruments 相关信息，如：URLSession 或 backtrace 信息，但这仍足以讓其他团队调查此问题。&lt;/p&gt;

&lt;p&gt;这就是你可以如何使用 HTTP Traffic Instrument 来诊断来自你的 APP 流量的来源和内容，以确保你可以控管你的 APP 在运行时执行的操作。&lt;/p&gt;

&lt;h2 id=&quot;更进一步&quot;&gt;更进一步&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;开始使用 Instruments 来检测你的 APP！&lt;/li&gt;
  &lt;li&gt;建议替你的 URLSession 和 URLSessionTask 命名，方便我们定位并修复问题。&lt;/li&gt;
  &lt;li&gt;适配最新的网络协议。&lt;/li&gt;
  &lt;li&gt;如果你的 APP 没有存在性能或者功能异常相关的问题，也请你持续的检测你发送了多少的流量，以消除不必要的流量产生。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;现在我们知道了新版本 Instruments 13 with Network template 的强大功能、新的视图、task 以及 transaction 的概念、新版本请求都有哪些标签及状态组成，并且也经由一个实际的 demo APP 了解如何一步一步的利用 Instruments 检测文中提到的四个问题，并且逐步的修复这些问题，利用 backtrace 查看代码调用栈，修复代码，并验证问题是否被正确的修复，最后，我们也知道如何导出 HAR 格式的错误报告。&lt;/p&gt;

&lt;p&gt;总的来说，今年 WWDC21 推出的新版 Instruments 还是非常的令人惊艳，比起以往的版本算是做了很大的升级，十分推荐大家尝试看看！&lt;/p&gt;

&lt;p&gt;Happy Coding！&lt;/p&gt;
</description>
        <pubDate>Sun, 20 Jun 2021 00:37:22 +0800</pubDate>
        <link>http://localhost:4000/ios/wwdc21/instruments/2021/06/20/wwdc21-network-instruments-intro.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/wwdc21/instruments/2021/06/20/wwdc21-network-instruments-intro.html</guid>
        
        
        <category>ios</category>
        
        <category>wwdc21</category>
        
        <category>instruments</category>
        
      </item>
    
      <item>
        <title>Aspects 源碼梳理</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;之前曾在項目中使用 Aspects hook Objective-C 的一些特定方法以達到數據埋點並且上報的能力，當時對於它的具體實現及源碼細節並沒有深入追究，這次藉由重新複習 iOS runtime 的時候，重新梳理了下 Aspects 的代碼實現以及原理。&lt;/p&gt;

&lt;p&gt;相信大家都知道 iOS 是門動態語言，它的 runtime 特性很具特色也是 iOS 的精華所在，但是對於如何使用這個神奇的特性，大家可能也是一知半解。Aspects 良好的向大家展示了如何運用 runtime 在實際的項目中，它提供的能力在 app 也是很實際會遇到的應用例子，所以想更加理解 runtime 的運用很推薦大家讀讀 Aspects 源碼。&lt;/p&gt;

&lt;h2 id=&quot;aop-vs-oop&quot;&gt;AOP v.s. OOP&lt;/h2&gt;

&lt;p&gt;Aspects 是 iOS 中實現 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&quot;&gt;AOP 設計模式&lt;/a&gt;的一種實現。&lt;/p&gt;

&lt;p&gt;OOP 注重的是對象的屬性、行為的封裝，AOP 專注於某個重複的處理步驟或運算邏輯，從中進行切面的擷取，以降低耦合度。&lt;/p&gt;

&lt;p&gt;比如：你有一個 event tracking 的需求，以 OOP 來說你可能會運用一些封裝方法，在每個方法都加上這個 tracking 方法，但是以 AOP 來看，就是把這些 tracking 的方法提取出來，運用動態特性，實現這些程式碼耦合，OOP 及 AOP 不是互斥而是需要配合。&lt;/p&gt;

&lt;p&gt;在 iOS 裡面使用 AOP 可以實現無代碼入侵，主要可以用於一些具有橫向（跨模塊）的服務，如：Logger、Event tracking、Cache 等等。&lt;/p&gt;

&lt;h2 id=&quot;nsmethodsignature--nsinvocation&quot;&gt;NSMethodSignature &amp;amp; NSInvocation&lt;/h2&gt;

&lt;p&gt;由於 Aspects 運用到了 iOS runtime 的 method swizzling，&lt;/p&gt;

&lt;p&gt;在 iOS 中調用方法除了&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一般方式：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[某個類的實例 方法名: 參數];&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;PerformSelector 系列：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[某個類的實例 performSelector: @selector(方法:) withObject: 參數];&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;還能利用 NSMethodSignature 以及 NSInvocation 完成方法調用。&lt;/p&gt;

&lt;p&gt;在 Aspects 中也用到了。這裡先來複習一下。&lt;/p&gt;

&lt;h3 id=&quot;nsmethodsignature-方法簽名&quot;&gt;NSMethodSignature 方法簽名&lt;/h3&gt;

&lt;p&gt;NSMethodSignature 如名稱所表示，它記錄了一個方法中的返回值以及參數，並且用了特定規則的符號字串來標示。有兩個方式可以創建 NSMethodSignature，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;NSObject 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&lt;/code&gt; 或者 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ (NSMethodSignature *)instanceMethodSignatureForSelector:(SEL)aSelector&lt;/code&gt;，利用 Selector 拿到方法簽名。&lt;/li&gt;
  &lt;li&gt;NSMethodSignature 也提供了方法可以利用特定的 char 組成字符串來表示方法的返回以及參數的類型，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ (nullable NSMethodSignature *)signatureWithObjCTypes:(const char *)types;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如：NSString 的實例方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (BOOL)containsString:(NSString *)str;&lt;/code&gt;
表示為：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c@:@&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;c 表示返回值類型 Bool&lt;/li&gt;
  &lt;li&gt;@ 表示 receiver，也就是這個方法的對象（self）&lt;/li&gt;
  &lt;li&gt;: 表示 SEL (_cmd)&lt;/li&gt;
  &lt;li&gt;@ 表示第一個參數 NSString&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中 self 以及 _cmd 是固定隱含的，也就是說你只需要定義返回值以及參數類型。每個類型對應的字符官方已經定義好了，如果不知道可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@encode()&lt;/code&gt;查詢，不需要 hard-code，詳細定義可以參考官方的對照表（https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100）。&lt;/p&gt;

&lt;h3 id=&quot;nsinvocation-調用方式&quot;&gt;NSInvocation 調用方式&lt;/h3&gt;

&lt;p&gt;蘋果官方表示&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;An Objective-C message rendered as an object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是說蘋果把消息傳遞的消息體（包含了 target, selector, arguments 以及 return value）封裝成了一個 NSObject 方便使用。&lt;/p&gt;

&lt;p&gt;你可以任意改變 NSInvocation 對象的 target（對象）, selector（方法標示），所以這意味著藉由修改 target 或者 selector 你可以把 invocation 對象重複的使用，而當 invocation 對象被 invoke 之後 return value 會自動被設置（因為已經調用了方法並且拿到回傳值了）。&lt;/p&gt;

&lt;p&gt;初始化這個對象只能用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+ (NSInvocation *)invocationWithMethodSignature:(NSMethodSignature *)sig&lt;/code&gt;，傳入 NSMethodSignature，不能用 NSObject 的 alloc+init。&lt;/p&gt;

&lt;p&gt;還有就是 invocation 默認不會持有它的參數，如果初始化完 invocation 參數可能會消失的話，你需要自己調用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)retainArguments&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最後使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)invoke;&lt;/code&gt; 會根據 invocation 的參數（target, selector, methodSignature）就可以調用該方法並設置返回值了。&lt;/p&gt;

&lt;p&gt;舉個栗子：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)run {
	NSMethodSignature *signature = [NSMethodSignature signatureWithObjCTypes:[@&quot;v@:@&quot; UTF8String]];
	NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
	invocation.selector = NSSelectorFromString(@&quot;test:&quot;);
	NSString *test = @&quot;argu1&quot;;
	invocation.target = self;
	[invocation setArgument:&amp;amp;test atIndex:2]; // index從2開始第一個參數，0表示target，1是selector
	[invocation invoke];
}
    
- (void)test:(NSString *)test {
    NSLog(@&quot;test: %@&quot;, test);
}
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至於找不到方法的處理方式，網上很多資源，這裡就不多說了，&lt;/p&gt;

&lt;p&gt;直接來看下 Aspects 的源碼吧。&lt;/p&gt;

&lt;h2 id=&quot;aspects-內部結構&quot;&gt;Aspects 內部結構&lt;/h2&gt;

&lt;h3 id=&quot;_aspectblock&quot;&gt;_AspectBlock&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct _AspectBlock {
	__unused Class isa;
	AspectBlockFlags flags;
	__unused int reserved;
	void (__unused *invoke)(struct _AspectBlock *block, ...);
	struct {
		unsigned long int reserved;
		unsigned long int size;
		// requires AspectBlockFlagsHasCopyDisposeHelpers
		void (*copy)(void *dst, const void *src);
		void (*dispose)(const void *);
		// requires AspectBlockFlagsHasSignature
		const char *signature;
		const char *layout;
	} *descriptor;
	// imported variables
} *AspectBlockRef;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;aspectinfo&quot;&gt;AspectInfo&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;先說結論：這個類主要紀錄 NSInvocation 訊息，它將 NSInvocation 包裝一層，如：所有參數訊息、及原本的 NSInvocation&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Aspects 在 .h 檔案定義了 AspectInfo protocol，在 hook 方法的時候會傳入一 block，而這個 block 必須遵守這個協議。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// The AspectInfo protocol is the first parameter of our block syntax.
@protocol AspectInfo &amp;lt;NSObject&amp;gt;

/// The instance that is currently hooked.
- (id)instance;

/// The original invocation of the hooked method.
- (NSInvocation *)originalInvocation;

/// All method arguments, boxed. This is lazily evaluated.
- (NSArray *)arguments;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著，Aspects 在 .m 檔案上，
聲明了繼承 NSObject 的 AspectInfo 類，並實現 AspectInfo 協議。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface AspectInfo : NSObject &amp;lt;AspectInfo&amp;gt;
- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;
@property (nonatomic, unsafe_unretained, readonly) id instance;
@property (nonatomic, strong, readonly) NSArray *arguments;
@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的對應實現&lt;/p&gt;

&lt;p&gt;把外面傳進來的對象以及原始的 invocation 保存至 AspectInfo。&lt;/p&gt;

&lt;p&gt;arguments 是一個懶加載方法，返回的是原始 invocation 的 aspects_arguments array。&lt;/p&gt;

&lt;p&gt;aspects_arguments 的實現是 NSInvocation 的 Aspects category 擴展（見下面）。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation AspectInfo

@synthesize arguments = _arguments;

- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation {
    NSCParameterAssert(instance);
    NSCParameterAssert(invocation);
    if (self = [super init]) {
        _instance = instance;
        _originalInvocation = invocation;
    }
    return self;
}

- (NSArray *)arguments {
    // Lazily evaluate arguments, boxing is expensive.
    if (!_arguments) {
        _arguments = self.originalInvocation.aspects_arguments;
    }
    return _arguments;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;nsinvocation-aspects&quot;&gt;NSInvocation (Aspects)&lt;/h3&gt;

&lt;p&gt;aspects_arguments 返回該 NSInvocation 中的所有參數。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NSInvocation (Aspects)
- (NSArray *)aspects_arguments;
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這裡的 for-loop 是從 index 2 開始，然後呼叫了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_argumentAtIndex&lt;/code&gt; 自定義方法返回方法簽名裡面指定 index 的 type encoding string。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSArray *)aspects_arguments {
	NSMutableArray *argumentsArray = [NSMutableArray array];
	for (NSUInteger idx = 2; idx &amp;lt; self.methodSignature.numberOfArguments; idx++) {
		[argumentsArray addObject:[self aspect_argumentAtIndex:idx] ?: NSNull.null];
	}
	return [argumentsArray copy];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以這邊有兩個研究點：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;為什麼 index 從 2 開始：
 根據上述的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@encode()&lt;/code&gt; type encoding，會以 “返回值 type + 參數 types” 組合的編碼，還有另外的隱含參數：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self&lt;/code&gt; 以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_cmd&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;如：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     - (void)tap; =&amp;gt; &quot;v@:&quot;
     - (int)tapWithView:(double)pointx; =&amp;gt; &quot;i@:d&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;可知：前三位代表 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;返回值 + @(self) + :(_cmd)&lt;/code&gt;，第一位返回值不在 arguments 的計數範圍，所以扣掉第一位返回值後，從第三位開始才是傳入的參數（index = 2 的位置）。&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;Function&lt;/th&gt;
          &lt;th style=&quot;text-align: center&quot;&gt;return value&lt;/th&gt;
          &lt;th style=&quot;text-align: right&quot;&gt;0&lt;/th&gt;
          &lt;th style=&quot;text-align: right&quot;&gt;1&lt;/th&gt;
          &lt;th&gt;2&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;tap&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;v&lt;/td&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;@&lt;/td&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;:&lt;/td&gt;
          &lt;td&gt;N/A&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;tapWithView&lt;/td&gt;
          &lt;td style=&quot;text-align: center&quot;&gt;v&lt;/td&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;@&lt;/td&gt;
          &lt;td style=&quot;text-align: right&quot;&gt;:&lt;/td&gt;
          &lt;td&gt;d&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;

    &lt;p&gt;所以從 index 2 開始才能得到我們要的所有參數。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_argumentAtIndex&lt;/code&gt; 實現原理：&lt;/p&gt;

    &lt;p&gt;這裡有借鏡了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ReactiveCocoa&lt;/code&gt; 的取得方法簽名參數的實現方法&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Thanks to the ReactiveCocoa team for providing a generic solution for this.
 - (id)aspect_argumentAtIndex:(NSUInteger)index {

 const char *argType = [self.methodSignature getArgumentTypeAtIndex:index];

 // Skip const type qualifier.
 if (argType[0] == _C_CONST) argType++;

 #define WRAP_AND_RETURN(type) do { type val = 0; [self getArgument:&amp;amp;val atIndex:(NSInteger)index]; return @(val); } while (0)

 if (strcmp(argType, @encode(id)) == 0 || strcmp(argType, @encode(Class)) == 0) {
     __autoreleasing id returnObj;
     [self getArgument:&amp;amp;returnObj atIndex:(NSInteger)index];
     return returnObj;
 } else if (strcmp(argType, @encode(SEL)) == 0) {
     SEL selector = 0;
     [self getArgument:&amp;amp;selector atIndex:(NSInteger)index];
     return NSStringFromSelector(selector);
 } else if (strcmp(argType, @encode(Class)) == 0) {
     __autoreleasing Class theClass = Nil;
     [self getArgument:&amp;amp;theClass atIndex:(NSInteger)index];
     return theClass;
     // Using this list will box the number with the appropriate constructor, instead of the generic NSValue.
 } else if (strcmp(argType, @encode(char)) == 0) {
     WRAP_AND_RETURN(char);
 } else if (strcmp(argType, @encode(int)) == 0) {
     WRAP_AND_RETURN(int);
 } else if (strcmp(argType, @encode(short)) == 0) {
     WRAP_AND_RETURN(short);
 } else if (strcmp(argType, @encode(long)) == 0) {
     WRAP_AND_RETURN(long);
 } else if (strcmp(argType, @encode(long long)) == 0) {
     WRAP_AND_RETURN(long long);
 } else if (strcmp(argType, @encode(unsigned char)) == 0) {
     WRAP_AND_RETURN(unsigned char);
 } else if (strcmp(argType, @encode(unsigned int)) == 0) {
     WRAP_AND_RETURN(unsigned int);
 } else if (strcmp(argType, @encode(unsigned short)) == 0) {
     WRAP_AND_RETURN(unsigned short);
 } else if (strcmp(argType, @encode(unsigned long)) == 0) {
     WRAP_AND_RETURN(unsigned long);
 } else if (strcmp(argType, @encode(unsigned long long)) == 0) {
     WRAP_AND_RETURN(unsigned long long);
 } else if (strcmp(argType, @encode(float)) == 0) {
     WRAP_AND_RETURN(float);
 } else if (strcmp(argType, @encode(double)) == 0) {
     WRAP_AND_RETURN(double);
 } else if (strcmp(argType, @encode(BOOL)) == 0) {
     WRAP_AND_RETURN(BOOL);
 } else if (strcmp(argType, @encode(bool)) == 0) {
     WRAP_AND_RETURN(BOOL);
 } else if (strcmp(argType, @encode(char *)) == 0) {
     WRAP_AND_RETURN(const char *);
 } else if (strcmp(argType, @encode(void (^)(void))) == 0) {
     __unsafe_unretained id block = nil;
     [self getArgument:&amp;amp;block atIndex:(NSInteger)index];
     return [block copy];
 } else {
     NSUInteger valueSize = 0;
     NSGetSizeAndAlignment(argType, &amp;amp;valueSize, NULL);

     unsigned char valueBytes[valueSize];
     [self getArgument:valueBytes atIndex:(NSInteger)index];

     return [NSValue valueWithBytes:valueBytes objCType:argType];
 }
 return nil;
 #undef WRAP_AND_RETURN
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcmp&lt;/code&gt; 這個方法是判斷我們從方法簽名裡面取出來的 type encoding 是否跟 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@encode(id)&lt;/code&gt; 的 type encoding 是一樣的，如果返回 0，則表示類型是相同的。&lt;/p&gt;

    &lt;p&gt;所以就依序根據各種類型比較判斷。基本數據類型就會依據 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WRAP_AND_RETURN(type)&lt;/code&gt; 宏定義的方法呼叫 NSInvocation 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getArgument:atIndex:&lt;/code&gt; 方法，用來取得對應的參數，最後返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@(val)&lt;/code&gt; Number 對象。&lt;/p&gt;

    &lt;p&gt;最後，block 及 struct 也會返回對應的對象。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;aspectidentifier&quot;&gt;AspectIdentifier&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Tracks a single aspect.
@interface AspectIdentifier : NSObject

+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;

- (BOOL)invokeWithInfo:(id&amp;lt;AspectInfo&amp;gt;)info;

@property (nonatomic, assign) SEL selector;
@property (nonatomic, strong) id block;
@property (nonatomic, strong) NSMethodSignature *blockSignature;
@property (nonatomic, weak) id object;
@property (nonatomic, assign) AspectOptions options;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它其實就是 Aspects 用來描述某一個切片的一個封裝類，類裡面記錄了切片需要的信息，如：原本類的 selector，你想要 hook 的 block 方法，block 的方法簽名，原本類或實例對象，以及 AspectOptions 調用時機。&lt;/p&gt;

&lt;p&gt;以及兩個方法（下文會介紹）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;產生 AspectIdentifier 類方法&lt;/li&gt;
  &lt;li&gt;切片調用方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;aspectcontainer&quot;&gt;AspectContainer&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Tracks all aspects for an object/class.
@interface AspectsContainer : NSObject

- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;

- (BOOL)removeAspect:(id)aspect;

- (BOOL)hasAspects;

@property (atomic, copy) NSArray *beforeAspects;
@property (atomic, copy) NSArray *insteadAspects;
@property (atomic, copy) NSArray *afterAspects;

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一個紀錄所有 AspectIdentifier 的容器，包含了三個 Array，分別紀錄前調用、完全取代、以及後調用的 AspectIdentifier。&lt;/p&gt;

&lt;h3 id=&quot;aspecttracker&quot;&gt;AspectTracker&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface AspectTracker : NSObject

- (id)initWithTrackedClass:(Class)trackedClass;

@property (nonatomic, strong) Class trackedClass;
@property (nonatomic, readonly) NSString *trackedClassName;
@property (nonatomic, strong) NSMutableSet *selectorNames;
@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;

- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;
- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;
- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;AspectTracker 用來追蹤你要 hook 的類，trackedClass 是你要 hook 的類，trackedClassName 是要 hook 的類名，selectorNames 紀錄所有要被 hook 的 selector name，selectorNamesToSubclassTrackers 是一個字典，key 為 selector name，value 為一組 AspectTracker set。&lt;/p&gt;

&lt;h2 id=&quot;aspects-hook-流程&quot;&gt;Aspects hook 流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;利用 NSObject category，增加了兩個 hook 方法，類方法以及實例方法。所以只要是 NSObject 類都可以直接使用下面兩個方法。&lt;/p&gt;

    &lt;p&gt;方法需要傳入四個參數，作者在註釋上都說得滿清楚的&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;原方法的 selector&lt;/li&gt;
      &lt;li&gt;AspectOptions，可選 before、instead 或者 after&lt;/li&gt;
      &lt;li&gt;遵循 AspectInfo protocol 的 Block，Aspects 會複製被 hook 的原方法的方法簽名&lt;/li&gt;
      &lt;li&gt;返回的錯誤訊息，如果有的話&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;返回值是 AspectToken 可以用來取消這個 hook 操作。&lt;/p&gt;

    &lt;p&gt;註：Aspects 不能 hook 靜態方法。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /// Adds a block of code before/instead/after the current `selector` for a specific class.
 ///
 /// @param block Aspects replicates the type signature of the method being hooked.
 /// The first parameter will be `id&amp;lt;AspectInfo&amp;gt;`, followed by all parameters of the method.
 /// These parameters are optional and will be filled to match the block signature.
 /// You can even use an empty block, or one that simple gets `id&amp;lt;AspectInfo&amp;gt;`.
 ///
 /// @note Hooking static methods is not supported.
 /// @return A token which allows to later deregister the aspect.
 + (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                            withOptions:(AspectOptions)options
                             usingBlock:(id)block
                                  error:(NSError **)error;
	
 /// Adds a block of code before/instead/after the current `selector` for a specific instance.
 - (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector
                            withOptions:(AspectOptions)options
                             usingBlock:(id)block
                                  error:(NSError **)error;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;這裡滿有趣的，作者提到&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Aspects uses Objective-C message forwarding to hook into messages. This will create some overhead. Don’t add aspects to methods that are called a lot. Aspects is meant for view/controller code that is not called a 1000 times per second.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Adding aspects returns an opaque token which can be used to deregister again. All calls are thread safe.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Aspects 利用了 Objective-C 的消息轉發機制 hook 消息，這樣會帶來性能上的消耗。所以不要把它用在會被呼叫很多次的方法，它是設計給 View/ViewController 使用，不要用在一秒被呼叫1000次的方法。XD&lt;/p&gt;

    &lt;p&gt;且加完 Aspects 後，會返回一個 token，這個 token 可以拿來註銷 hook 方法。而所有的呼叫都是線程安全的（用到了自旋鎖。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;這兩個方法其實內部都是調用了同一個私有方法 aspect_add&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) {
     NSCParameterAssert(self);
     NSCParameterAssert(selector);
     NSCParameterAssert(block);
	
     __block AspectIdentifier *identifier = nil;
     aspect_performLocked(^{
         if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) {
             AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector);
             identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];
             if (identifier) {
                 [aspectContainer addAspect:identifier withOptions:options];
	
                 // Modify the class to allow message interception.
                 aspect_prepareClassAndHookSelector(self, selector, error);
             }
         }
     });
     return identifier;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;這個方法有五個參數，&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;self：自己&lt;/li&gt;
      &lt;li&gt;selector：你需要 hook 的 SEL&lt;/li&gt;
      &lt;li&gt;options：定義的 AspectOptions，你可選擇 hook 方法被調用的時機，如：AspectPositionAfter（之後調，這個是預設）、AspectPositionInstead（完全取代原方法，比較危險） 、AspectPositionBefore（之前調）或 AspectOptionAutomaticRemoval（只執行一次）&lt;/li&gt;
      &lt;li&gt;block：你要執行的方法&lt;/li&gt;
      &lt;li&gt;error：如果發生錯誤&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;一開始對必要參數做檢查，接著利用了自定義的自旋鎖來保證線程安全，這個鎖對於少量代碼的操作性能較高，這裡就先不討論自旋鎖優先級反轉的問題。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static void aspect_performLocked(dispatch_block_t block) {
     static OSSpinLock aspect_lock = OS_SPINLOCK_INIT;
     OSSpinLockLock(&amp;amp;aspect_lock);
     block();
     OSSpinLockUnlock(&amp;amp;aspect_lock);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;接著，檢查這個方法是否可以被 hook，具體代碼實現比較長就不貼出來了，感興趣可以下載源碼來看一下，這段主要做了這些事情：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;建立黑名單：把系統方法，retain/release/autorelease/forwardInvocation 加入黑名單，不允許 hook 這些方法&lt;/li&gt;
      &lt;li&gt;如果你 hook 的是 dealloc，則 options 只能是 AspectPositionBefore&lt;/li&gt;
      &lt;li&gt;Hook 對象必須有實現這個方法&lt;/li&gt;
      &lt;li&gt;如果你 hook 元類 (meta-class) 方法的話，則會多判斷：
        &lt;ul&gt;
          &lt;li&gt;先取得全局的字典，裡面記錄被 hook 的類以及對應的 AspectTracker 對象。這個 tracker 記錄著 hook 的類，類名，所有被 hook 的方法名，以及 selectorNamesToSubclassTrackers 是個字典，記錄著某個方法名（key），對應的所有子類的 AspectTracker（value）。所以當它從 selectorNamesToSubclassTrackers 裡面檢查到某個方法已經有 AspectTracker，則表示已經有它的子類 hook 過這個方法了，此時便不允許再次 hook。&lt;/li&gt;
          &lt;li&gt;接著，用 for-loop 遍歷所有父類，如果 tracker 紀錄的所有被 hook 的方法名已經有了，則不允許再次 hook&lt;/li&gt;
          &lt;li&gt;如果上述都不滿足，即所有子類和父類都沒有重複 hook，則產生一個 AspectTracker 對象，然後把 hook 相關信息紀錄起來，子類存完同步到父類，然後不斷的往父類遍歷直到 root class(NSObject)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;以上是檢查方法是否可以被 hook。&lt;/p&gt;

    &lt;p&gt;如果都通過，開始進入 hook 方法存儲流程，&lt;/p&gt;

    &lt;p&gt;首先要產生 AspectsContainer，這裡利用了關聯對象創建或者取出 AspectsContainer，接著產生 AspectIdentifier，AspectIdentifier 紀錄了 selector 方法，block 執行回調，block 方法簽名，options，以及一個 weak object 指向了自己（調用對象）。&lt;/p&gt;

    &lt;p&gt;那是怎麼產生 AspectIdentifier 呢？透過封裝的 AspectIdentifier 類方法&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; + (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error {
     NSCParameterAssert(block);
     NSCParameterAssert(selector);
	    
     NSMethodSignature *blockSignature = aspect_blockMethodSignature(block, error); // TODO: check signature compatibility, etc.
     if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) {
         return nil;
     }
	
     AspectIdentifier *identifier = nil;
     if (blockSignature) {
         identifier = [AspectIdentifier new];
         identifier.selector = selector;
         identifier.block = block;
         identifier.blockSignature = blockSignature;
         identifier.options = options;
         identifier.object = object; // weak
     }
     return identifier;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;這裡需要先拿到 block 的方法簽名，拿到後檢查跟原有對象的方法簽名是否一致。因為你傳進來 block 裡面放著你想要做的事情，為了方便方法交換後的 block 方法調用，所以需要轉為方法簽名，也是文章一開始提到過的方法調用的技巧。&lt;/p&gt;

    &lt;p&gt;這裡轉換用了文章一開始提到的 AspectBlockRef 結構體，將 block bridge 到這結構體，然後把方法描述轉為方法簽名，這個結構體是模仿了 block 的內存佈局。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; const char *signature = (*(const char **)desc);
 return [NSMethodSignature signatureWithObjCTypes:signature];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;拿到 AspectIdentifier 後，加入 AspectsContainer。（AspectIdentifier 可以視為是每個 Aspect 的基本信息，比如 hook 的方法，要執行的 block 方法簽名，原 block 等）&lt;/p&gt;

    &lt;p&gt;AspectsContainer 裡面有三個 array，分別紀錄先調用，後調用或者完全取代調用的 AspectIdentifier。&lt;/p&gt;

    &lt;p&gt;如果都完成了信息紀錄，則開始進入 hook 流程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;準備 Hook 流程&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) {
 NSCParameterAssert(selector);
    
     Class klass = aspect_hookClass(self, error);
     Method targetMethod = class_getInstanceMethod(klass, selector);
     IMP targetMethodIMP = method_getImplementation(targetMethod);
	    
     if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
         // Make a method alias for the existing method implementation, it not already copied.
         const char *typeEncoding = method_getTypeEncoding(targetMethod);
         SEL aliasSelector = aspect_aliasForSelector(selector);
         if (![klass instancesRespondToSelector:aliasSelector]) {
             __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
             NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
         }
	
         // We use forwardInvocation to hook in.
         class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
         AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;aspect_hookClass 做了哪些事情？&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Class statedClass = self.class;
      Class baseClass = object_getClass(self);
      NSString *className = NSStringFromClass(baseClass);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;self.class 實際上調用的是&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      + (Class)class {
  		return self;
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;返回的是類對象本身，&lt;/p&gt;

        &lt;p&gt;而 object_getClass(self) 拿到的實際上是對象的 isa 指針&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      Class object_getClass(id obj)
      {
          if (obj) return obj-&amp;gt;getIsa();
          else return Nil;
      }
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      // Already subclassed
      if ([className hasSuffix:AspectsSubclassSuffix]) {
          return baseClass;
		
          // We swizzle a class object, not a single object.
      }else if (class_isMetaClass(baseClass)) {
          return aspect_swizzleClassInPlace((Class)self);
          // Probably a KVO'ed class. Swizzle in place. Also swizzle meta classes in place.
      }else if (statedClass != baseClass) {
          return aspect_swizzleClassInPlace(baseClass);
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;如果 isa 指針指向的類是有 Aspects 後綴的，表示已經被 hook 過了，就直接返回這個類。&lt;/p&gt;

        &lt;p&gt;如果類沒有前綴，且是元類，則調用 aspect_swizzleClassInPlace。&lt;/p&gt;

        &lt;p&gt;如果非元類也非元類，同時類對象與 isa 指針指向的類非同一個，表示是 KVO 產生的類，因為 KVO 會在 runtime 產生一個中間類達成 KVO 機制，這時候對 KVO 產生的中間類調用 aspect_swizzleClassInPlace。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      static Class aspect_swizzleClassInPlace(Class klass) {
      NSCParameterAssert(klass);
      NSString *className = NSStringFromClass(klass);
		
      _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) {
          if (![swizzledClasses containsObject:className]) {
              aspect_swizzleForwardInvocation(klass);
              [swizzledClasses addObject:className];
          }
      });
      return klass;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;_aspect_modifySwizzledClasses 會傳入一個 NSMutableSet 紀錄方法交換的類名，由於返回的 set 是全局的，且做了線程安全保護，如果發現當前的類名不在這個 set 裡面，則調用 aspect_swizzleForwardInvocation 這個方法，並且把當前類名加入 set 裡面。&lt;/p&gt;

        &lt;p&gt;如果上述都不滿足，則 runtime 動態產生帶有 Aspects 後綴的子類。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Default case. Create dynamic subclass.
  const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;
  Class subclass = objc_getClass(subclassName);
	
  if (subclass == nil) {
      subclass = objc_allocateClassPair(baseClass, subclassName, 0);
      if (subclass == nil) {
          NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName];
          AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);
          return nil;
      }
	
      aspect_swizzleForwardInvocation(subclass);
      aspect_hookedGetClass(subclass, statedClass);
      aspect_hookedGetClass(object_getClass(subclass), statedClass);
      objc_registerClassPair(subclass);
  }
	
  object_setClass(self, subclass);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;這邊大量用了 runtime，&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;objc_getClass 先取得 Aspects 新創建的類&lt;/li&gt;
          &lt;li&gt;如果找不到，則用 objc_allocateClassPair 創建一個&lt;/li&gt;
          &lt;li&gt;aspect_swizzleForwardInvocation 這個方法做比較多事情，稍後一起說，主要是交換了方法的具體實現&lt;/li&gt;
          &lt;li&gt;aspect_hookedGetClass(subclass, statedClass);
      aspect_hookedGetClass(object_getClass(subclass), statedClass);
      這兩個把剛剛新創的類 isa 指針以及 class 都指向了 statedClass，也就是這個類對象本身&lt;/li&gt;
          &lt;li&gt;最後 objc_registerClassPair(subclass) 註冊新創的類&lt;/li&gt;
          &lt;li&gt;object_setClass(self, subclass) 把調用的對象 isa 指向新創的類。也就是 self -&amp;gt; subClass -&amp;gt; statedClass。然後返回新創的類。&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;到目前為止，就完成了 aspect_hookClass，並把 self hook 成了 xxx_Aspects_。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;aspect_swizzleForwardInvocation 做了哪些事？&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static void aspect_swizzleForwardInvocation(Class klass) {
  NSCParameterAssert(klass);
	    
  // If there is no method, replace will act like class_addMethod.
  IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;);
	    
  if (originalImplementation) {
      class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;);
  }
  AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;這裏把 forwardInvocation 替換成了 Aspects 定義的 &lt;strong&gt;ASPECTS_ARE_BEING_CALLED&lt;/strong&gt; 實現，如果成功返回，則在類上添加 &lt;strong&gt;aspects_forwardInvocation 名的方法，具體實作就是 __ASPECTS_ARE_BEING_CALLED&lt;/strong&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ASPECTS_ARE_BEING_CALLED&lt;/strong&gt; 做了事情很多，但也是精華所在：
        &lt;ol&gt;
          &lt;li&gt;把從 hook forwardInvocation 拿到的 invocation 中拿到原始 selector 並且轉換成 aspects alias 的 selector，然後設置給 invocation&lt;/li&gt;
          &lt;li&gt;利用關聯對象拿到實例對象的 AspectsContainer 以及類對象的 AspectsContainer&lt;/li&gt;
          &lt;li&gt;初始化 AspectInfo，傳入 self 及 invocation&lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;接著先執行定義成先調用的類及實例對象的 block&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Before hooks.
 aspect_invoke(classContainer.beforeAspects, info);
 aspect_invoke(objectContainer.beforeAspects, info);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;直接取代&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Instead hooks.
 BOOL respondsToAlias = YES;
 if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) {
     aspect_invoke(classContainer.insteadAspects, info);
     aspect_invoke(objectContainer.insteadAspects, info);
 }else {
     Class klass = object_getClass(invocation.target);
     do {
         if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) {
             [invocation invoke];
             break;
         }
     }while (!respondsToAlias &amp;amp;&amp;amp; (klass = class_getSuperclass(klass)));
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;後調用&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // After hooks.
 aspect_invoke(classContainer.afterAspects, info);
 aspect_invoke(objectContainer.afterAspects, info);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;都是把第三步產生的 AspectInfo 傳入。&lt;/p&gt;

            &lt;p&gt;這裡利用宏定義了調用方法 aspect_invoke，節省了方法調用出入棧的開銷成本。&lt;/p&gt;

            &lt;p&gt;裡面做了兩件事情，依序調用每個 aspect，也就是你所 hook 的方法，並把 AspectInfo 上下文傳入你的 block，然後把調用過的 aspect 加入等待被移除的 array。&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // This is a macro so we get a cleaner stack trace.
 #define aspect_invoke(aspects, info) \
 for (AspectIdentifier *aspect in aspects) {\
  [aspect invokeWithInfo:info];\
  if (aspect.options &amp;amp; AspectOptionAutomaticRemoval) { \
 aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \
  } \
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;

            &lt;p&gt;invokeWithInfo 這個方法挺有意思，它把原本的 invocation 參數加入，之前產生的 block 的方法簽名 invocation 中，然後調用你的 block。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;如果直接取代那一段沒有正常執行，則呼叫原本方法的實現，並替換為原本的 selector&lt;/li&gt;
          &lt;li&gt;最後，前調用、直接取代以及後調用都做完了之後，把這三個階段完成的 aspect 方法移除&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;aspect_remove：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static BOOL aspect_remove(AspectIdentifier *aspect, NSError **error) {
      NSCAssert([aspect isKindOfClass:AspectIdentifier.class], @&quot;Must have correct type.&quot;);
		
      __block BOOL success = NO;
      aspect_performLocked(^{
          id self = aspect.object; // strongify
          if (self) {
              AspectsContainer *aspectContainer = aspect_getContainerForObject(self, aspect.selector);
              success = [aspectContainer removeAspect:aspect];
		
              aspect_cleanupHookedClassAndSelector(self, aspect.selector);
              // destroy token
              aspect.object = nil;
              aspect.block = nil;
              aspect.selector = NULL;
          }else {
              NSString *errrorDesc = [NSString stringWithFormat:@&quot;Unable to deregister hook. Object already deallocated: %@&quot;, aspect];
              AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc);
          }
      });
      return success;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;remove 一樣用了一個自旋鎖保證線程安全，&lt;/p&gt;

        &lt;p&gt;先利用關聯對象拿到 AspectsContainer，移除 aspect（AspectIdentifier）以及 AspectsContainer 的關係。&lt;/p&gt;

        &lt;p&gt;aspect_cleanupHookedClassAndSelector 清除之前 hook 的類以及 selector。
  並清除 aspect 相關信息。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  aspect.object = nil;
  aspect.block = nil;
  aspect.selector = NULL;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_cleanupHookedClassAndSelector&lt;/code&gt; 這個方法也是精華所在&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Class klass = object_getClass(self);
 	BOOL isMetaClass = class_isMetaClass(klass);
	   	
  if (isMetaClass) {
      klass = (Class)self;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;p&gt;先拿到類的 isa 指針，如果指向的就是元類，則用自己，如果還不是元類，則用 isa 指針指向的類。然後拿到的類的方法實現位置，把之前交換的 aspect alias 後的 selector 與原本的 selector 交換回來。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Method targetMethod = class_getInstanceMethod(klass, selector);
 IMP targetMethodIMP = method_getImplementation(targetMethod);
  		if (aspect_isMsgForwardIMP(targetMethodIMP)) {
  		
      const char *typeEncoding = method_getTypeEncoding(targetMethod);
      SEL aliasSelector = aspect_aliasForSelector(selector);
      Method originalMethod = class_getInstanceMethod(klass, aliasSelector);
      IMP originalIMP = method_getImplementation(originalMethod);
      NSCAssert(originalMethod, @&quot;Original implementation for %@ not found %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
		
      class_replaceMethod(klass, selector, originalIMP, typeEncoding);
      AspectLog(@&quot;Aspects: Removed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));
      }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;這裡是以類為基礎，所以假設你有同個類的兩個實例對象 hook 了同一個方法，先 remove 的會把另一個實例對象的 hook 方法也一併移除。&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_deregisterTrackedSelector&lt;/code&gt; 接著把之前提到的全局字典紀錄每個類以及對應的 AspectTracker 對象取出，並移除 selector name，selector name 底下的 sub class tracker，並從字典中移除紀錄，ㄧ樣用 for-loop 遍歷直到父類指向 NSObject，則結束。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Get the aspect container and check if there are any hooks remaining. Clean up if there are not.
  AspectsContainer *container = aspect_getContainerForObject(self, selector);
  if (!container.hasAspects) {
      // Destroy the container
      aspect_destroyContainerForObject(self, selector);
	
      // Figure out how the class was modified to undo the changes.
      NSString *className = NSStringFromClass(klass);
      if ([className hasSuffix:AspectsSubclassSuffix]) {
          Class originalClass = NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:@&quot;&quot;]);
          NSCAssert(originalClass != nil, @&quot;Original class must exist&quot;);
          object_setClass(self, originalClass);
          AspectLog(@&quot;Aspects: %@ has been restored.&quot;, NSStringFromClass(originalClass));
          // We can only dispose the class pair if we can ensure that no instances exist using our subclass.
          // Since we don't globally track this, we can't ensure this - but there's also not much overhead in keeping it around.
          //objc_disposeClassPair(object.class);
      }else {
          // Class is most likely swizzled in place. Undo that.
          if (isMetaClass) {
              aspect_undoSwizzleClassInPlace((Class)self);
          }else if (self.class != klass) {
          	aspect_undoSwizzleClassInPlace(klass);
          }
      }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_destroyContainerForObject&lt;/code&gt; 清除了關聯對象中的 AspectsContainer。&lt;/p&gt;

        &lt;p&gt;如果類名包含了 aspect 後綴，則把後綴去除，然後把 self 的指針指向原本的類，如果不是直接調用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_undoSwizzleClassInPlace&lt;/code&gt;。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_undoSwizzleClassInPlace&lt;/code&gt;：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static void aspect_undoSwizzleClassInPlace(Class klass) {
  NSCParameterAssert(klass);
  NSString *className = NSStringFromClass(klass);
	
  _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) {
      if ([swizzledClasses containsObject:className]) {
          aspect_undoSwizzleForwardInvocation(klass);
          [swizzledClasses removeObject:className];
      }
  });
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;這個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_aspect_modifySwizzledClasses&lt;/code&gt; 也是之前提到的全局紀錄所有交換過的類，這邊還原了所有類的 forward invocation，並把類從全局 set 裡移除。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  static void aspect_undoSwizzleForwardInvocation(Class klass) {
  NSCParameterAssert(klass);
	    
  Method originalMethod = class_getInstanceMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName));
  Method objectMethod = class_getInstanceMethod(NSObject.class, @selector(forwardInvocation:));
	    
  // There is no class_removeMethod, so the best we can do is to retore the original implementation, or use a dummy.
  IMP originalImplementation = method_getImplementation(originalMethod ?: objectMethod);
  class_replaceMethod(klass, @selector(forwardInvocation:), originalImplementation, &quot;v@:@&quot;);
	
  AspectLog(@&quot;Aspects: %@ has been restored.&quot;, NSStringFromClass(klass));
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;這裡做的就是，把之前交換過的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__aspects_forwardInvocation:&lt;/code&gt; 以及原本類的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forwardInvocation:&lt;/code&gt; 方法交換回來。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;如此一來就完成了所有的清除以及 Swizzling 回復作業了。&lt;/p&gt;

    &lt;p&gt;現在我們了解了：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;怎麼產生新的 hook 類，並且與原本的類交換 invocation&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__ASPECTS_ARE_BEING_CALLED__&lt;/code&gt; 怎麼調用你的 block&lt;/li&gt;
      &lt;li&gt;最後如何清除以及 swizzling 還原&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;因為我們是從 aspect_hookClass 進入，沒想到裡面就做了這麼多事情，最後返回了一個 apsects 新建的類，我們需要拿這個產生的類做交換。&lt;/p&gt;

    &lt;p&gt;所以讓我們再回來最一開始的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aspect_prepareClassAndHookSelector&lt;/code&gt; 方法。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;aspect_prepareClassAndHookSelector 續：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Class klass = aspect_hookClass(self, error);
 Method targetMethod = class_getInstanceMethod(klass, selector);
 IMP targetMethodIMP = method_getImplementation(targetMethod);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;這裡返回的 klass 就是 aspect 產生的類，由於它的 isa 指向的是原本的類，所以我們可以拿到原本類 selector 方法的具體實現位置。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; if (!aspect_isMsgForwardIMP(targetMethodIMP)) {
     // Make a method alias for the existing method implementation, it not already copied.
     const char *typeEncoding = method_getTypeEncoding(targetMethod);
     SEL aliasSelector = aspect_aliasForSelector(selector);
     if (![klass instancesRespondToSelector:aliasSelector]) {
         __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding);
         NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass);
     }

     // We use forwardInvocation to hook in.
     class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding);
     AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;如果方法實現不是走 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_objc_msgForward&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_objc_msgForward_stret&lt;/code&gt; 消息轉發，先把原本 selector 轉為 aspect alias selector，然後加到 aspects 新產生的類的方法列表中，接者，替換這個 selector 的方法實現為走 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_objc_msgForward&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_objc_msgForward_stret&lt;/code&gt; 的消息轉發機制。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;總結&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;最後簡單做個總結吧，Aspects 整體思路：當你調用某個類或是某個實例對象的 hook 方法，並傳入你想 hook 的 selector，以及你要執行的 block，還有調用時機點。Aspects 會在內部產生新的 xx_aspects_ 類對象，修改 isa 指針，把你的 block 轉為自定義的 block AspectsInfo 結構體，裡面當然包含了原先的 block 以及轉換後的 block 簽名。接著，修改消息轉發流程，把 forwardInvocation hook 到 aspects_forwardInvocation，並在裡面根據具體調用時機點，調用 block 方法簽名，然後把原本類的 selector 實現改為走消息轉發方式，當類原本方法被調用的同時，實際上會經由消息轉發走到 aspects_forwardInvocation 並且調用 block。當調用完你的 block 後，會把 block 消息並且回復消息轉發機制，調用原本類的方法。&lt;/p&gt;

&lt;p&gt;Aspects 源碼也不到一千行，但裡面運用到 AOP 以及 runtime 的許多技術，十分值得我們研究一番。&lt;/p&gt;

&lt;p&gt;p.s. 這篇文章拖了好久ＲＲＲ&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Apr 2020 17:03:23 +0800</pubDate>
        <link>http://localhost:4000/ios/aspects/runtime/2020/04/20/aspects-source-code-summary.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/aspects/runtime/2020/04/20/aspects-source-code-summary.html</guid>
        
        
        <category>ios</category>
        
        <category>aspects</category>
        
        <category>runtime</category>
        
      </item>
    
      <item>
        <title>Atomic 原理與線程安全</title>
        <description>&lt;h2 id=&quot;寫在前面&quot;&gt;寫在前面&lt;/h2&gt;

&lt;p&gt;這篇僅研究 iOS 中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 屬性底層源碼實現與線程安全的關係。至於 atomic 的介紹以及與 nonatomic 的比較就不在這邊展開了。&lt;/p&gt;

&lt;h2 id=&quot;atomic-能保證線程安全嗎&quot;&gt;Atomic 能保證線程安全嗎？&lt;/h2&gt;

&lt;p&gt;首先，我們看下線程安全在 Wiki 的定義：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;執行緒安全是編程中的術語，指某個函數、函數庫在多執行緒環境中被調用時，
能夠正確地處理多個執行緒之間的共享變量，使程序功能正確完成。 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也就是說，在你的程序中，若含有多個執行緒同時的執行某一段任務，在 A 執行緒執行完成後的結果不應該被 B 執行緒的結果所影響。這就可以被稱作是線程安全的，即能夠&lt;strong&gt;保證資料的一致性及完整性&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在回答這個問題之前，我們先理解一下 atomic 在底層是怎麼實現的。&lt;/p&gt;

&lt;h2 id=&quot;atomic-源碼實現&quot;&gt;Atomic 源碼實現&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Set value&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (!atomic) {
    oldValue = *slot;
    *slot = newValue;
} else {
    spinlock_t&amp;amp; slotlock = PropertyLocks[slot];
    slotlock.lock();
    oldValue = *slot;
    *slot = newValue;        
    slotlock.unlock();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Get value&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spinlock_t&amp;amp; slotlock = PropertyLocks[slot];
slotlock.lock();
id value = objc_retain(*slot);
slotlock.unlock();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Apple 官方開源的 objc4-750 裡面，可以發現在屬性在讀寫的時候，進行了 atomic 的判斷式，如果是 atomic 的屬性，會以該屬性的記憶體位置當作 key 值去底層維護的 mapping 表找出對應的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spinlock&lt;/code&gt;，並且加鎖，待完成任務後才解鎖。&lt;/p&gt;

&lt;p&gt;所以，我們知道了，&lt;strong&gt;atomic 會利用 spinlock 自旋鎖來確保讀寫過程中不被其他的執行緒篡改內容&lt;/strong&gt;，算是線程安全。&lt;/p&gt;

&lt;p&gt;所以我寫了一個例子來測試是否如我們想的那樣呢。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t concurrent = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // Thread A
    dispatch_async(concurrent, ^{
        // Task A
        NSLog(@&quot;Enter Thread A&quot;);
        for (int count = 0; count &amp;lt; 100; count++) {
            self.atomicStr = @&quot;A&quot;;
            self.nonAtomicStr = @&quot;A&quot;;
            if (![@&quot;A&quot; isEqualToString:_atomicStr]) {
                NSLog(@&quot;[Atomic] Task A's result is not expected. %@&quot;, _atomicStr);
            }
            if (![@&quot;A&quot; isEqualToString:_nonAtomicStr]) {
                NSLog(@&quot;[NonAtomic] Task A's result is not expected. %@&quot;, _nonAtomicStr);
            }
        }
    });
    
    // Thread B
    dispatch_async(concurrent, ^{
        // Task B
        NSLog(@&quot;Enter Thread B&quot;);
        for (int count = 0; count &amp;lt; 100; count++) {
            self.atomicStr = @&quot;B&quot;;
            self.nonAtomicStr = @&quot;B&quot;;
            if (![@&quot;B&quot; isEqualToString:_atomicStr]) {
                NSLog(@&quot;[Atomic] Task B's result is not expected. %@&quot;, _atomicStr);
            }
            if (![@&quot;B&quot; isEqualToString:_nonAtomicStr]) {
                NSLog(@&quot;[NonAtomic] Task B's result is not expected. %@&quot;, _nonAtomicStr);
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這裡我開了兩個線程同時分別修改 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;atomic&lt;/code&gt; 及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nonatomic&lt;/code&gt; 字串。因為我們已經知道 atomic 在賦值的時候會加鎖，來保證當前線程下的任務不會被其他線程修改。所以，我們預期 Task A 每次賦值後的結果要為 A，Task B 需為 B。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Atomic[43745:2218609] Enter Thread A
Atomic[43745:2218674] Enter Thread B
Atomic[43745:2218609] [Atomic] Task A's result is not expected. B
Atomic[43745:2218674] [NonAtomic] Task B's result is not expected. A
Atomic[43745:2218674] Enter Thread A
Atomic[43745:2218609] Enter Thread B
Atomic[43745:2218674] [Atomic] Task A's result is not expected. B
Atomic[43745:2218674] [NonAtomic] Task A's result is not expected. B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但卻出現這樣的結果。&lt;strong&gt;A 與 B 任務還是會互相影響。宣告 atomic 與 nonatomic 結果是一樣的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;所以 atomic 不是線程安全嗎？&lt;/p&gt;

&lt;p&gt;這邊我的理解是，atomic 是安全的，但是它的職責只在於&lt;strong&gt;保證多執行緒下對同個屬性的讀寫不會同時進行&lt;/strong&gt;。所以當 A 開始寫入，B 的寫入會進入等待，等到 A 一寫完鎖釋放後，B 馬上又鎖上進行寫的操作。這時候 A 的讀取又會進入等待，等到 B 寫完鎖釋放了之後，這時候在 Task A 裡面就會讀取到 B 的內容。反之，如果 A 的讀取快於 B 的寫入，那麼，A 讀取到的內容就會是預期的 A。至於&lt;strong&gt;執行緒的執行順序得看系統的調度了&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;如何實現完整的線程安全&quot;&gt;如何實現完整的線程安全？&lt;/h2&gt;

&lt;p&gt;其實就是確保單一任務或接口方法的原子性，讓某一執行緒在執行某段任務或某個方法的時候是唯一的。
上述例子為了方便測試我加上了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@synchronized&lt;/code&gt; 鎖。這樣就是預期的結果了。&lt;/p&gt;

&lt;p&gt;如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Thread A
    dispatch_async(concurrent, ^{
        // Task A
        NSLog(@&quot;Enter Thread A&quot;);
        @synchronized (self) {
            for (int count = 0; count &amp;lt; 100; count++) {
                self.atomicStr = @&quot;A&quot;;
                self.nonAtomicStr = @&quot;A&quot;;
                if (![@&quot;A&quot; isEqualToString:_atomicStr]) {
                    NSLog(@&quot;[Atomic] Task A's result is not expected. %@&quot;, _atomicStr);
                }
                if (![@&quot;A&quot; isEqualToString:_nonAtomicStr]) {
                    NSLog(@&quot;[NonAtomic] Task A's result is not expected. %@&quot;, _nonAtomicStr);
                }
            }
        }
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完整範例請看 -&amp;gt; &lt;a href=&quot;https://github.com/wchuang/devSwift/tree/master/Atomic&quot;&gt;AtomicTest&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;結論&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Atomic 是安全的，它保證了多執行緒下，讀和寫同時間的操作只能有一個，也就是資料的唯一性&lt;/strong&gt;。只是它無法確保是哪個線程先執行，才造成了最後的結果不一致。所以，還需要對每個線程裡的任務做鎖的保護，確保最後的結果是預期完整的。&lt;/p&gt;

&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Jul 2019 18:50:03 +0800</pubDate>
        <link>http://localhost:4000/ios/atomic/thread/2019/07/04/atomic-thread-safe-or-not.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/atomic/thread/2019/07/04/atomic-thread-safe-or-not.html</guid>
        
        
        <category>ios</category>
        
        <category>atomic</category>
        
        <category>thread</category>
        
      </item>
    
      <item>
        <title>自己打造 Autorelease Pool</title>
        <description>&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;當你對某個 NSObject 的實例呼叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;autorelease&lt;/code&gt; 方法，相當於呼叫了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[NSAutoreleasePool addObject:self]&lt;/code&gt; 的類方法，這個方法會把這個 object 加入 autorelease pool 裡。&lt;/p&gt;

</description>
        <pubDate>Thu, 27 Jun 2019 17:26:00 +0800</pubDate>
        <link>http://localhost:4000/ios/autoreleasepool/2019/06/27/make-ios-autorelease-pool.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/autoreleasepool/2019/06/27/make-ios-autorelease-pool.html</guid>
        
        
        <category>ios</category>
        
        <category>autoreleasepool</category>
        
      </item>
    
      <item>
        <title>iOS 介面渲染及優化</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;這篇文章主要想要整理一下 iOS 上介面如何渲染以及怎麼優化，雖說是 iOS，但其實原理都是一樣的。分為下列三個知識點來討論：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;圖片如何從 raw data 呈現在螢幕上？&lt;/li&gt;
  &lt;li&gt;哪些情況下會造成介面顯示不流暢？&lt;/li&gt;
  &lt;li&gt;要如何解決這些問題？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;圖片如何顯示&quot;&gt;圖片如何顯示?&lt;/h2&gt;

&lt;p&gt;圖片如何從最一開始拿到的 raw data，最後展現在螢幕上讓使用者看到？所謂的 raw data 可能會從網路或者 bundle 的一張圖片取得，然後經由 CPU 計算解碼，GPU 渲染至緩存區，最後與硬體同步顯示在螢幕上。概觀圖如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wchuang/wchuang.github.io/master/static/img/_posts/vsync.001.jpeg&quot; alt=&quot;V-sync&quot; /&gt;&lt;/p&gt;

&lt;p&gt;傳統 CRT 顯示器在顯示影像會由上到下垂直掃描，掃描完成後就會呈現一個 Frame 的完整畫面，同時電子槍會回到初始位置繼續下一次的掃描。為了讓系統 Controller 知道什麼時候掃描完成並要開始下一次掃描，顯示器會發出定時信號。&lt;/p&gt;

&lt;p&gt;定時信號又分為&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 水平同步信號(H-Sync): 當顯示器完成當前的行掃描並要換到新的一行時。
2. 垂直同步信號(V-Sync): 當一個 Frame 完成掃描並繪製完成，電子槍回復到初始位置，準備下一個 Frame 的掃描時。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;垂直同步信號(V-Sync)也就是所謂的 FPS，顯示器刷新的頻率，也是我們用來評估是否畫面造成卡頓的因素之一。&lt;/p&gt;

&lt;p&gt;當系統 Controller 收到來自顯示器的 V-Sync 訊號量後，它就知道螢幕已經完成一次顯示。這時候它會向 FrameBuffer 讀取下一個 Frame 的資料。&lt;/p&gt;

&lt;p&gt;Framebuffer 在 Wiki 的定義：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A framebuffer (frame buffer, or sometimes framestore) is a portion of RAM[1]
 containing a bitmap that drives a video display. 
It is a memory buffer containing a complete frame of data.[2] 

Modern video cards contain framebuffer circuitry in their cores. 
This circuitry converts an in-memory bitmap into a video signal 
that can be displayed on a computer monitor. 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;所以我們知道它是一塊記憶體緩存區，負責存放由 CPU/GPU 處理後的一塊完整 Frame data。&lt;/p&gt;

&lt;p&gt;而現代的 framebuffer 幾乎都為雙緩存機制。這個機制下，GPU 會先渲染一個 Frame 的資料存入第一個 buffer 裡，讓 Controller 可以讀取。當下一個 Frame 渲染完成後，GPU 會把 Controller 的指針指向第二個 buffer，讓 Controler 讀取第二個 buffer 的資料。&lt;/p&gt;

&lt;p&gt;但是如果 GPU 每次渲染完第二個 Frame 後就讓 Controller 讀取第二個 buffer 的資料，有可能因為 Controller 還未讀取完第一個 Frame 的資料就切換到第二個，造成了畫面畫面撕裂現象。畫面的上半部顯示舊的影像，下半部顯示了新的影像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wchuang/wchuang.github.io/master/static/img/_posts/screen_tearing.jpg&quot; alt=&quot;Screen_tearing&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那麼要如何解決這個問題？&lt;/p&gt;

&lt;p&gt;GPU 也有 V-Sync 的同步機制，當 V-Sync 開啟時，GPU 會等待顯示器的 V-Sync 信號發出後才進行下一個 Frame 的渲染以及緩存區更新。這樣便解決了畫面撕裂問題，但是也因為沒辦法先行處理下一個 Frame 的渲染，所以可能會有延遲的情況產生。&lt;/p&gt;

&lt;h2 id=&quot;為什麼卡頓&quot;&gt;為什麼卡頓?&lt;/h2&gt;

&lt;p&gt;在 iOS 中，當一個 V-Sync 通知到來的時候，Core Animation 會利用 CADisplayLink 通知 APP，APP main thread 會開始在 CPU 計算顯示內容，如：view 的創建、Frame 的計算、圖片解碼、文本繪製等。然後 CPU 會將計算好的內容提交給 GPU，由 GPU 進行變換、合成、渲染，最後將渲染的結果存到緩存區中，讓 Controller 讀取、顯示在螢幕上並等待下一次 V-Sync 到來。&lt;/p&gt;

&lt;p&gt;上述是一個完整的 V-Sync 圖像處理流程。但是如果在一次的 V-Sync 時間內，CPU 及 GPU 沒辦法即時完成任務並提交到緩存區內，這一次的 Frame 就會被丟棄。也就是說在下一個 V-Sync 來臨時，Controller 依舊讀取到 buffer 內的舊資料並顯示，這就是造成介面卡頓的原因。&lt;/p&gt;

&lt;p&gt;所以，CPU 或 GPU 不論哪個阻礙了顯示流程，都會造成掉幀情況。所以開發時，需要分別對 CPU 及 GPU 壓力進行評估及優化來避免這類的問題。&lt;/p&gt;

&lt;h2 id=&quot;如何解決&quot;&gt;如何解決?&lt;/h2&gt;

&lt;p&gt;要知道如何解決前，需要先了解 CPU 及 GPU 在處理圖像時，都做了哪些事情。&lt;/p&gt;

&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;對象創建&lt;/p&gt;

    &lt;p&gt;對象的創建會涉及到內存的分配、屬性調整、計算 retain count 等的操作，相對來說較耗用 CPU 資源。所以可以盡量利用比較&lt;strong&gt;輕量的對象來取代&lt;/strong&gt;。如：用 struct 取代 class 來定義 model，或者當不需要響應使用者觸摸事件的控件，可以使用 CALayer 來代替 UIView。&lt;strong&gt;多復用已創建的對象&lt;/strong&gt;，可以建立緩存存放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;對象調整&lt;/p&gt;

    &lt;p&gt;對象的屬性調整也是很消耗 CPU 的地方。由於 UIView 關於顯示相關的屬性，如 frame/bounds/transform 等實際上也是映射到 CALayer 屬性，所以修改 UIView 的這些屬性的時候，實際上消耗的性能遠大於其他的屬性。而當 UIView 進行層級調整的時候，UIView 及 CALayer 之間也會出現多次方法調用以及通知。&lt;/p&gt;

    &lt;p&gt;我這邊對 CALayer 做了擴展並加了自定義屬性來測試，發現 &lt;strong&gt;CALayer 會在 runtime 時自己添加上屬性方法&lt;/strong&gt;。若是對 UIView 做擴展及自定義屬性的話，在調用時會出現找不到方法造成 crash，你需要自己在 runtime 添加屬性方法。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // MyLayer
 @interface MyLayer : CALayer
 @end
	
 @interface MyLayer (MyTest)
 @property (copy, nonatomic) NSString *name;
 @end
		
 @implementation MyLayer
 @end
		
 @implementation MyLayer (MyTest)
 @end
	
 // Test
 MyLayer *layer = [[MyLayer alloc] init];
 [self.view.layer addSublayer:layer];
 layer.backgroundColor = UIColor.redColor.CGColor;
	    
 for (int i = 0; i &amp;lt; 1000000; i++) {
     layer.name = [NSString stringWithFormat:@&quot;MyLayer: %d&quot;, i];
     layer.frame = CGRectMake(50, 50, 10, 10);
     NSLog(@&quot;layer name: %@&quot;, layer.name);
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // MyView
 @interface MyView : UIView
 @end
	
 @interface MyView (MyTest)
 @property (copy, nonatomic) NSString *viewName;
 @end
		
 @implementation MyView
 @end
		
 @implementation MyView (MyTest)
 @end
	
 // Test
 MyView *view = [[MyView alloc] init];
 view.frame = CGRectMake(0, 0, 100, 100);
 view.viewName = @&quot;MyView&quot;; // Crash!!
 [self.view addSubview:view];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;觀察調用棧會發現在設定自定義屬性 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 的時候，底層做了很多事情，包含了添加屬性方法、尋找屬性方法、設定屬性內容、發送 KVO 通知、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA::Layer::begin_change()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA::Layer::end_change()&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CA::Transaction::ensure_compact()&lt;/code&gt;、加鎖等的操作。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/wchuang/wchuang.github.io/master/static/img/_posts/custom_layer.png&quot; alt=&quot;Custom_layer&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;對象銷毀&lt;/p&gt;

    &lt;p&gt;對象銷毀雖然消耗的資源不明顯，但若是累積起來也是不容忽視。尤其是一次釋放大量對象的時候。也可以盡可能的放在 background thread 執行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;佈局計算&lt;/p&gt;

    &lt;p&gt;佈局計算是最常見消耗系統資源的地方。如果能先在 background thread 計算好並作緩存就能避免這些問題。但上述也提到，調整佈局相關屬性(frame/bounds/center)其實都會對應到 CALayer 層級操作，還有同步通知問題，是非常消耗性能的地方。所以最好&lt;strong&gt;先做預先計算及緩存，並且一次性的調整，而不要多次、頻繁的改變這些屬性&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本計算&lt;/p&gt;

    &lt;p&gt;如果在介面上有大量的文本需求（如：facebook news feed 或微信朋友圈），常常需要計算文本寬、高度，可以利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NSAttributedString&lt;/code&gt; 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[string boundingRectWithSize:options:context:];&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[string drawWithRect:options:context:];&lt;/code&gt; 這兩個方法來實現以提升效能，由於是 thread safe，所以可以放在 background thread 執行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本渲染&lt;/p&gt;

    &lt;p&gt;螢幕上能看到的所有文本內容控件，包含 UIWebView，其底層都是通過 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoreText&lt;/code&gt; 來排版並繪製成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt; 顯示。常見的控件（UILabel、UITextView）等，其排版以及繪製都是在主線程進行。所以當有大量的文本需要顯示的時候，CPU 的壓力就會非常大。&lt;/p&gt;

    &lt;p&gt;對此解決方式可以&lt;strong&gt;自定義一個文本控件，並用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TextKit&lt;/code&gt;或&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoreText&lt;/code&gt;對文本異步繪製&lt;/strong&gt;。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoreText&lt;/code&gt; 對象創建好後，能直接取得文本的寬度高度等訊息。&lt;strong&gt;避免了多次計算（調整 UILabel 大小的時候計算一次、UILabel 繪製的時候內部又再算一次）&lt;/strong&gt;。且&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CoreText&lt;/code&gt;對象佔用內存較少，可以緩存下來做多次復用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖片解碼&lt;/p&gt;

    &lt;p&gt;當你用 UIImage 或 CGImageSource 的那幾個方法創建圖片的時候，圖片資料並不會馬上被解碼。當圖片設置到 UIImageView 或 CALayer.contents 時，並且 CALayer 被提交到 GPU 渲染前，CGImage 中的資料才得以解碼。由於這一步是 UI 操作，會發生在主線程，且不可避免。優化方式可以先在 &lt;strong&gt;background thread 把圖片繪製到 CGBitmapContext 中，然後由 Bitmap 直接創建圖片&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖像繪製&lt;/p&gt;

    &lt;p&gt;圖像繪製指的是使用以 CG 開頭的底層方法，把圖像繪製到畫布中，然後從畫布創建圖片並顯示的一個過程。最常見的地方就是在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[UIView drawRect:]&lt;/code&gt;方法裡面。由於 CoreGraphic 的方法是 thread safe 的，所以可以在 background thread 繪製。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
     CGContextRef contextRef = CGBitmapContextCreate();
     // Draw your context.
     CGImageRef imageRef = CGBitmapContextCreateImage(contextRef);
     CGContextRelease(contextRef);
     dispatch_async(dispatch_get_main_queue(), ^{
         layer.contents = (__bridge id _Nullable)(imageRef);
         CGImageRelease(imageRef);
     });
 });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gpu&quot;&gt;GPU&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;紋理渲染&lt;/p&gt;

    &lt;p&gt;所有的 Bitmap，不論是圖片或是文本的內容，最終都是要由內存提交到顯示卡記憶體，並綁定為 GPU 的 Texture。所以不管是提交的過程或是 GPU 調整和渲染 Texture 的過程，都要消耗不少 GPU 的資源。&lt;/p&gt;

    &lt;p&gt;當在較短時間內顯示大量的圖片時（如 UITableView 存在很多圖片並快速滑動的時候），CPU 佔用率很低，GPU 佔用率非常高，此時介面依然會掉幀。避免此情況的方法只能&lt;strong&gt;避免在短時間內的大量圖片顯示，盡可能將多張圖片合併成一張顯示&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;當圖片過大，超過 GPU 的最大 Texture size 時，圖片需要先由 CPU 進行預處理，這對 CPU 及 GPU 都會帶來額外的資源消耗。可以從這個網站查看各個 iPhone 機型對應的 &lt;a href=&quot;http://iosres.com/&quot;&gt;MAX Texture size&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;視圖混合&lt;/p&gt;

    &lt;p&gt;當多個 View（CALayer）重疊在一起的時候，GPU 會先把它們混合到一起。如果視圖結構過於複雜，混合的過程也會消耗很多 GPU 資源。為了減少這種情況的資源消耗，可以盡量&lt;strong&gt;減少 view 的層級以及數量，並設置 opaque 為不透明，減少計算 background color 時的 alpha 合成&lt;/strong&gt;。也可以將多張視圖預先渲染為一張圖片顯示。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圖形生成&lt;/p&gt;

    &lt;p&gt;CALayer 的 border、圓角、陰影、遮罩、CASharpLayer 的矢量圖形顯示，通常會造成離屏渲染（Off-Screen Rendering)。&lt;/p&gt;

    &lt;p&gt;GPU 的屏幕渲染分為兩種：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;On-Screen Rendering：指的是 GPU 的渲染操作在當前用於顯示的緩存區中。&lt;/li&gt;
      &lt;li&gt;Off-Screen Rendering：指的是 GPU 的渲染操作不在當前用於顯示的緩存區中，而是另外建立一個緩存區做渲染操作。如果我們&lt;strong&gt;重寫了 drawRect: 方法，並使用了 Core Graphics 方法進行繪製得到 Bitmap 後在交給 GPU 顯示&lt;/strong&gt;，也算是一種離屏渲染，因為是由 CPU 渲染。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;而離屏渲染（Off-Screen Rendering）的代價是很高的，原因在於：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;創建新的緩存區&lt;/strong&gt;：系統必須多花費資源重新創建。&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;上下文切換&lt;/strong&gt;：必須先由 On-Screen 切換到 Off-Screen 環境，待 Off-Screen Rendering 結束後，把渲染結果同步到 On-Screen 環境。&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;我們要避免離屏渲染造成系統無謂的資源浪費，可以設置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CALayer.shouldRasterize&lt;/code&gt; 屬性為 YES，使得在離屏渲染發生的時候會將渲染後的內容緩存起來，在下一個 Frame 渲染時可以直接復用。但如果你又同時設置了 border、圓角 等其他屬性，緩存將不會起作用。&lt;/p&gt;

    &lt;p&gt;所以最好的方式，還是要避免上述的圓角、border、mask 等屬性的調用，可以用 CPU 渲染來代替。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;參考資料&quot;&gt;參考資料&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Framebuffer&quot;&gt;Framebuffer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Screen_tearing&quot;&gt;Screen_tearing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/documentation/quartzcore/cadisplaylink&quot;&gt;CADisplayLink&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/&quot;&gt;ibireme大神文章&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 23:56:57 +0800</pubDate>
        <link>http://localhost:4000/ios/performance/2019/06/24/ios-interfaces-rendering-and-refactor.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/performance/2019/06/24/ios-interfaces-rendering-and-refactor.html</guid>
        
        
        <category>ios</category>
        
        <category>performance</category>
        
      </item>
    
      <item>
        <title>如何使用 @autoclosure 設計 Swift APIs</title>
        <description>&lt;p&gt;Swift 中的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@autoclosure&lt;/code&gt; 屬性，可以讓你定義一個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;可自動取得一個閉包 (closure) 內的包裹 (wrapped)&lt;/code&gt; 的參數。它主要用於延緩執行時間，而不是當這個參數傳入的時候就直接使用，因為執行的動作可能有點耗時。這麼說有點繞口，下面是一個官方 Swift 標準函式庫的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 例子，我們來看看 Apple 是怎麼實現這個方法的。&lt;/p&gt;

&lt;p&gt;由於 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 只有在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debug&lt;/code&gt; 模式下才會被觸發，在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt; 模式下會被返回而不會執行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expression&lt;/code&gt;，完整的實作請看源碼: &lt;a href=&quot;https://github.com/apple/swift/blob/master/stdlib/public/core/Assert.swift&quot;&gt;Assert.swift&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func assert(_ expression: @autoclosure () -&amp;gt; Bool, 
			_ message: @autoclosure () -&amp;gt; String) {
	guard let isDebug else { return }

	if !expression() {
		assertionFailure(message())
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 的實作方式是用一般的閉包實現，那你會這樣呼叫：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assert({ someCondition() }, { &quot;hey, it failed.&quot; })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現在你只需要這樣即可，不用在傳入一個閉包參照。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assert(someCondition(), &quot;hey, it failed.&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那麼如何運用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@autoclosure&lt;/code&gt; 這個方便的特性在實際 APIs 設計上面呢？&lt;/p&gt;

&lt;p&gt;###1. Inlining assignments&lt;/p&gt;

&lt;p&gt;在方法呼叫的時候，把一個表達式當做一個參數傳入。一般在 iOS 處理畫面動畫你會用到：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIView.animate(withDuration: 0.25) {
	view.frame.origin.y = 100
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@autoclosure&lt;/code&gt; 中，我們定義一個方法來化簡這樣的呼叫方式。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func animate(_ animation: @autoclosure @escaping () -&amp;gt; Void, 
				duration: TimeInterval = 0.25) {
	UIView.animate(withDuration: duration, animations: animation)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如此一來，我們只需要傳入一個特定操作表達式，不用再寫額外的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{}&lt;/code&gt;。
增加了程式碼的可讀性以及降低複雜度。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;animate(view.frame.origin.y = 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-passing-errors-as-expressions&quot;&gt;2. Passing errors as expressions&lt;/h3&gt;

&lt;p&gt;我們常常會需要寫一個工具來處理 errors 的各種情況，此時使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@autoclosure&lt;/code&gt; 就變得非常方便。
例如：我們寫一個 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extension&lt;/code&gt; 來擴展 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Optional&lt;/code&gt;，讓我們可以容易的解包 (unwrap) 或拋出異常 (throwing API)。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension Optional {
	func unwrapOrThrow(_ errorExpression: @autoclosure () -&amp;gt; Error) throws -&amp;gt; Wrapped {
		guard let value = self else {
			throw errorExpression()
		}
		return value
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這跟上述的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assert&lt;/code&gt; 一樣，我們只需要關注在錯誤的表達式上面，而不需要每次都去判斷是否解包成功 (unwarp)。
我們現在可以這樣使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unwarpOrThrow&lt;/code&gt; API：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let name = try argument(at: 1).unwarpOrThrow(ArgumentError.missingName)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-type-inference-using-default-values&quot;&gt;3. Type inference using default values&lt;/h3&gt;

&lt;p&gt;很多時候當我們從 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TextField.text&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UserDefaults&lt;/code&gt; 或者其他地方取值的時候，常常會碰到可選值 (optional value) 的情況。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coins = (dictionary[&quot;numberOfCoins&quot;] as? Int) ?? 100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這樣的寫法用了很多操作符號，程式碼變得難以閱讀。
這時候可以用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@aotuclosure&lt;/code&gt; 來改善寫法。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let coins = dictioanry.value(forKey: &quot;numberOfCoins&quot;, defaultValue: 100)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;這邊賦予了一個預設值給 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;coins&lt;/code&gt;，當內容為 nil 的情況。這樣是不是好閱讀多了，也不需要每次都去判斷是否為 nil。:grin:
不過我們還需要一個方法擴展 Dictionary。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension Dictionary where Value == Any {
	func value&amp;lt;T&amp;gt;(forKey key: Key, defaultValue: @autoclosure () -&amp;gt; T) -&amp;gt; T {
		guard let value = self[key] as? T else { return defaultValue() }
		return value
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;結論&quot;&gt;結論&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@autoclosure&lt;/code&gt; 是一個很有用的工具，讓你可以關注在你想處理的事情上面，並減少了重複性判斷，大大增加了程式碼的可讀性。&lt;/p&gt;

&lt;h3 id=&quot;ref&quot;&gt;Ref.&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://www.swiftbysundell.com/posts/using-autoclosure-when-designing-swift-apis&quot;&gt;swiftbysundell&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 02 Mar 2019 16:31:08 +0800</pubDate>
        <link>http://localhost:4000/swift/ios/2019/03/02/autoclosure-swift-apis.html</link>
        <guid isPermaLink="true">http://localhost:4000/swift/ios/2019/03/02/autoclosure-swift-apis.html</guid>
        
        
        <category>swift</category>
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>那些你很少用的 Swift GCD 方法</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/documentation/dispatch&quot;&gt;Grand Central Dispatch&lt;/a&gt; (GCD) 相信每個 iOS 開發者都不陌生，它是蘋果提供用來操作多執行緒的一種底層技術，你可以選擇在串行 (serial) 或並行 (concurrent) 的 queue 中執行同步 (synchronous) 或者非同步 (asynchronous) 的任務，這邊就不多說了，最常看到的方法就是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DispatchQueue.global().async {

	// 耗時操作
	
	DispatchQueue.main.async {

		// UI 更新 
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但除此之外，GCD 還有很多很少被使用但是令人驚豔的方法，這邊會介紹 4 種這類的方法，大家下次可以試著在專案中使用看看，相信會有很大的效果。&lt;/p&gt;

&lt;h1 id=&quot;1-利用-dispatchworkitem-取消等待的任務&quot;&gt;1. 利用 DispatchWorkItem 取消等待的任務&lt;/h1&gt;

&lt;p&gt;有些人對於 GCD 有一個 &lt;strong&gt;錯誤認知&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一旦排定了 GCD 任務就沒辦法被取消，只有 Operation 才可以。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;實際上在 iOS 8 及 macOS 10.10 之後可以使用 DispatchWorkItem 來做到。&lt;/p&gt;

&lt;p&gt;應用場景：&lt;/p&gt;

&lt;p&gt;假設我們有一個 search bar 讓使用者進行關鍵字搜尋，當收到關鍵字時會向後端 API 發送搜尋請求。但考量到使用者打字的速度，不可能每次輸入一個字就發出網路請求，這可能會造成不必要的網路流量以及伺服器負擔。所以我們可以偵測當使用者輸入閒置超過 0.25 秒後才發送一個請求。&lt;/p&gt;

&lt;p&gt;底下是一個例子，我們可以簡單的用 DispatchWorkItem，不用 Timer 或 Operation 的複雜操作。也可以直接用 closure 閉包注入 GCD 中，不需要 @objc 或是 #selector。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SearchViewController: UIViewController, UISearchBarDelegate {

	private var pendingRequestWorkItem: DispatchWorkItem?
	
	// MARK: - UISearchBarDelegate	
	func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
		
		// Cancel the pending work item
		pendingRequestWorkItem?.cancel()
		
		// Build a request in a work item
		let requestWorkItem = DispatchWorkItem { [weak self] in
			self?.resultLoader.loadRequests(forQuery: searchText)
		}
		
		// Save it and execute after 250ms
		pendingRequestWorkItem = requestWorkItem
		DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(250), 
		                               execute: requestWorkItem)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-利用-dispatchgroup-執行一系列的任務&quot;&gt;2. 利用 DispatchGroup 執行一系列的任務&lt;/h1&gt;

&lt;p&gt;有時候我們希望可以做完一系列的任務 {A, B, C} 後，再做其他的任務 D。{ A, B, C } -&amp;gt; D。例如：在建立 model 之前會有多個 API 的 request，待全部 response 回來後才組成需要的 model。&lt;/p&gt;

&lt;p&gt;這時候可以利用 DispatchGroup 來達成同步任務。我們只需要注意 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enter()&lt;/code&gt; 以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;leave()&lt;/code&gt; 的呼叫是否一致。&lt;/p&gt;

&lt;p&gt;DispatchGroup 有另個好處可以開多個 DispatchGroup queue 異步的執行，而每個 queue 裡面的任務又可以同步完成。&lt;/p&gt;

&lt;p&gt;下面一個簡單的例子，從不同 datasource 取得資料，全部完成後存入 NoteCollection。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Create a group to synchronize our tasks.
let groip = DispatchGroup()

// NoteCollection is a thread-safe collection class for storing notes.
let collection = NoteCollection()

// The 'enter	()' method increments the group's task count
group.enter()
localDataSource.load { notes in 
	collection.add(notes)
	// while the 'leave()' method decrements it
	group.leave()
}

group.enter()
iCloudDataSource.load { notes in 
	collection.add(notes)
	group.leave()
}

group.enter()
backendDataSource.load { notes in 
	collection.add(notes)
	group.leave()
}

// This closure will be called when the group's task count reaches 0
group.notify(queue: .main) { [weak self] in
	self?.render(collection)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代碼重複的部份有點多，我們可以做一個 Array 的擴展來優化：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension Array where Element == DataSource {

	func load(completion: @escaping (NoteCollection) -&amp;gt; Void) {
	
		let group = DispatchGroup()
		let collection = NoteCollection()
		
		for dataSource in self {
		
			group.enter()
			dataSource.load { notes in
			
				collection.add(notes)
				group.leave()
			}
		}
		
		group.notify(queue: .main) {
		
			completion(collection)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;基於以上擴展，我們可以這樣呼叫&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dataSources: [DataSource] = [
	localDataSource,
	iCouldDataSource,
	backendDataSource
]

dataSources.load { [weak self] collection in

	self?.render(collection)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-利用-dispatchsemaphore-鎖住非同步的任務&quot;&gt;3. 利用 DispatchSemaphore 鎖住非同步的任務&lt;/h1&gt;

&lt;p&gt;雖然 DispatchGroup 提供了同步的方法等待所有任務執行完成，但對於不同 DispatchGroup queue 來說，彼此還是异步的進行。DispatchSemaphore 可以鎖住某個 DispatchGroup queue 的執行，藉以達成同步的效果。&lt;/p&gt;

&lt;p&gt;跟 DispatchGroup 一樣，DispatchSemaphore API 也很簡單，也是利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 或 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 來增加或減少內部計數。在呼叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 前呼叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 會 block 目前的操作一直到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;signal()&lt;/code&gt; 被呼叫。&lt;/p&gt;

&lt;p&gt;我們修改上面的例子，並另外建立一個 global queue 來加入 Semaphore 方法，因為呼叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wait()&lt;/code&gt; 會 block 當前的 queue。成功返回 NoteCollection，失敗則丟出錯誤。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension Array where Element == DataSource {

	func load() throws -&amp;gt; NoteCollection {
	
		let semaphore = DispatchSemaphore(value: 0)
		var loadedCollection: NoteCollection?
		
		let loadingQueue = DispatchQueue.global()
		
		loadingQueue.async {
		
			self.load(onQueue: loadingQueue) { collection in
			
				loadedCollection = collection
				
				// Unblock
				semaphore.signal()
			}
		}
		
		// Block and wait
		semaphore.wait(timeout: .noew() + 5)
		
		guare let collection = loadedCollection else {
		
			throw NoteLoadingError.timeout
		}
	
		return collection
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同步的呼叫方式&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let dataSource: [DataSource] = [
	localDataSource,
	iCloudDataSource,
	backendDataSource
]

do {
	let collection = try dataSource.load()
	output(collection)
} catch {
	output(error)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;4-利用-dispatchsource-監聽檔案是否被修改&quot;&gt;4. 利用 DispatchSource 監聽檔案是否被修改&lt;/h1&gt;

&lt;p&gt;這個鮮為人知的方法可以讓我們監控檔案是否被修改過，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;在線編輯&lt;/code&gt;的功能就可以利用這個方式實作出來。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DispatchSource&lt;/code&gt; 可以有很多種來源，例如：Timer source, User data, file system or memory pressure event，這裡我們用 file system 示範。直接看 code 吧。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class FileObserver {

	private let file: File
	private let queue: DispatchQueue
	private var source: DispatchSourceFileSystemObject?
	
	init(file: File) {
	
		self.file = file
		self.queue = DispatchQueue(label: &quot;com.test.fileobserver&quot;)
	}
	
	func start(closure: @escaping() -&amp;gt; Void) {
		
		let path = (file.path as NSString)
		let fileSystemRepresentation = path.fileSystemRepresentation
		
		let fileDescriptor = open(fileSystemRepresentation, O_EVTONLY)
		
		let source = DispatchSource.makeFileSystemObjectSource(fileDescriptor: fileDescriptor, eventMask: .write, queue: queue)
		
		source.setEventHandler(handler: closure)
		source.resume()
		
		self.source = source
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let observer = try FileObserver(file: file)

observer.start {
	print(&quot;File was changed&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;總結下來，GCD 還是挺厲害的也埋藏了一些好用的功能，比起利用 NSTimer 或者 Operation 可能會產生的問題小很多，也更安全一些！各位看倌可以多多挖掘 GCD 的應用場景。Happy Coding!&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.swiftbysundell.com/posts/a-deep-dive-into-grand-central-dispatch-in-swift&quot;&gt;A deep dive into Grand Central Dispatch in Swift&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Nov 2018 15:03:08 +0800</pubDate>
        <link>http://localhost:4000/gcd/swift/ios/2018/11/04/swift-gcd.html</link>
        <guid isPermaLink="true">http://localhost:4000/gcd/swift/ios/2018/11/04/swift-gcd.html</guid>
        
        
        <category>gcd</category>
        
        <category>swift</category>
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>What Is Mmap and How It Works?</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;MMAP(Memory-mapped file), 是一種源於 Unix/Linux 作業系統內存映射文件的方法，主要用於&lt;strong&gt;增加 I/O 存取效能&lt;/strong&gt;，尤其大文件效果更顯著。它在進程 process 中開闢一段&lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;虛擬內存&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;逐一字節的將一份文件或檔案從磁碟位置對應到該虛擬位置&lt;/em&gt;，這樣使得 process 可以直接操作該虛擬內存，如同操作該文件，而不需要調用 read/write 等系統方法。同時也減少了一次從文件拷貝的動作。&lt;/p&gt;

&lt;h1 id=&quot;原理&quot;&gt;原理&lt;/h1&gt;

&lt;p&gt;mmap 實現原理主要分為三個階段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start MMAP in process, creating a virtual mapping zone on virtual address space:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Process request a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap&lt;/code&gt; system fuction in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek a continuous and idle virtual address space in vitual memory address of current process.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Allocate a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt; struct for this virtual address space, and initialize the struct.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Insert the struct to linked list or tree of virtual address space of process.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Request a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap&lt;/code&gt; system fuction in kernal-space, not in user-space, and implement the mapping relationship between the disk address of file and virtual address space of current process:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;After allocating a new virtual address space, it will find the file descriptor in file descriptor table by the pointer of un-mapped files. And link to the struct file of every un-mapped file through the file descriptor in kernal’s opened file set. Every struct file will maintain a opened file in kernal one by one.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Link to module of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file_operations&lt;/code&gt; through the struct file and request function of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap&lt;/code&gt; in kernal-space, not in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int mmap(struct file *filp, struct vm_area_struct *vma)&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap&lt;/code&gt; function in kernal will locate the file physical address in disk by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt; module.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Build a mapping relationship table between the disk address of file and virtual address space of current process. However, there is no data mapping in main memory from virtual address space.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process start to read data on this virtual address space, that will occur &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt;&lt;/a&gt; and start copy document data from disk to main memory: (&lt;strong&gt;In step 1 and 2, there is only create virtual address space and compelte the mapping relationshop table, but the data do not copy into main memory yet. When starting read/write operations on process, just start to copy data.&lt;/strong&gt;)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;When process start to read or write data on mapping address on virtual address space, it find that it is not found on memory page. Due to there is only build a mapping and the file data is not copy to memory, so it occurs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Kernal request a page fault handler after confirming there are no illegal operations.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek to the memory page in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;swap cache&lt;/code&gt;, if not find, it will request &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nopage&lt;/code&gt; function in order to create page from disk to main memory.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Then the process can do read/write operations on main memory, if the data be changed, system will update those changed content in mapped disk address after a while. (You can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;msync&lt;/code&gt; function to update data right now.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;函數介紹&quot;&gt;函數介紹&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;參數&quot;&gt;參數&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;start: mapping virtual address space 的開始位置，如果傳入 NULL，kernal 會自動選擇 page-aligned address。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;length: mapping space 長度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prot: 內存保護機制。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PROT_EXEC  Pages may be executed.
  PROT_READ  Pages may be read.
  PROT_WRITE Pages may be written.
  PROT_NONE  Pages may not be accessed.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flags: 是否該映射區可以被其他 processes 看到。&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  MAP_SHARED Share this mapping.
  MAP_SHARED_VALIDATE This flag provides the same behavior as MAP_SHARED except that MAP_SHARED mappings ignore unknown flags in flags.
  MAP_PRIVATE Create a private copy-on-write mapping.
  MAP_32BIT Put the mapping into the first 2 Gigabytes of the process address space. 
  MAP_ANON Synonym for MAP_ANONYMOUS. Deprecated.
  ...    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fd: 文件描述詞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;offset: 文件位移量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;返回值&quot;&gt;返回值&lt;/h5&gt;

&lt;p&gt;如果建立成功，會返回一個指標指向這個映射空間的位置。假設失敗，將會回傳 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAP_FAILED (that is, (void *) -1)&lt;/code&gt;，以及 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;errno&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;與一般文件存取差異&quot;&gt;與一般文件存取差異&lt;/h1&gt;

&lt;p&gt;一般文件調用過程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process 發起讀取文件請求。&lt;/li&gt;
  &lt;li&gt;Kernal 通過尋找 file descriptor in file descriptor table，並且利用 kernal 中已開啟的文件集中的文件資訊找到該文件的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;判斷該文件是否在&lt;a href=&quot;https://en.wikipedia.org/wiki/Page_cache&quot;&gt;頁緩存 page cache&lt;/a&gt; 中，如果存在則返回該文件內容。不存在則利用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inode&lt;/code&gt; 定位到 physical address in disk，並拷貝文件內容到頁緩存中。之後再發起讀頁面請求，將頁緩存的資訊給該 process。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;總而言之，一般文件讀取為了提高效率及保護磁碟，會利用頁緩存技術。這樣造成讀文件的時候，需要先將文件從磁碟拷貝到頁緩存，但由於頁緩存在 kernal-space 中，不能被 user-space 訪問，所以必須將資料從頁緩存再拷貝到 user-space。&lt;strong&gt;這樣進行了兩次的資料拷貝&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而使用 mmap，利用建立新的 virtual address space 以及磁碟位置與 virtual address space 的映射，沒有進行文件拷貝。直到訪問資料時造成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt; 利用映射關係，&lt;strong&gt;只進行一次的資料拷貝&lt;/strong&gt;，就從磁碟拷貝至 user-space，讓 process 得以使用。&lt;/p&gt;

&lt;h1 id=&quot;優點&quot;&gt;優點&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;對文件存取繞過了 paging 技術操作，減少了資料的拷貝次數，並且利用 read/write in memory instead of I/O operations，大大提高效能。&lt;/li&gt;
  &lt;li&gt;內存映射文件可以只載入一部分內容到用戶空間，對於大型檔案非常有用。&lt;/li&gt;
  &lt;li&gt;實現了 user-space 及 kernal-space 的交互，兩空間的修改可以直接反映在映射區，並且被對方更新。&lt;/li&gt;
  &lt;li&gt;可以達到跨 process 溝通通信。&lt;/li&gt;
  &lt;li&gt;避免因為大量的 data I/O 造成的記憶體不足問題，&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;如何確保不會讀到其他位址&quot;&gt;如何確保不會讀到其他位址&lt;/h1&gt;

&lt;p&gt;MMAP 是利用自己的虛擬位址空間來處理 (必須先映射，否則無法透過 user-space 的虛擬記憶體存取)。所以其他 user-space 中的行程是沒辦法去存取這塊記憶體。因為其這塊超出的記憶體位址並沒有映射到它自己的虛擬記憶體位址，也因此當 user-space 存取超出的話，就會被作業系統踢出。&lt;/p&gt;

&lt;h1 id=&quot;參考資料&quot;&gt;參考資料&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/huxiao-tee/p/4660352.html&quot;&gt;mmap分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap函數說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 18 Jun 2018 17:17:35 +0800</pubDate>
        <link>http://localhost:4000/mmap/2018/06/18/what-is-mmap-and-how-it-works.html</link>
        <guid isPermaLink="true">http://localhost:4000/mmap/2018/06/18/what-is-mmap-and-how-it-works.html</guid>
        
        
        <category>mmap</category>
        
      </item>
    
      <item>
        <title>How to Make a Private CocoaPods?</title>
        <description>&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;CocoaPods is a great tool not only for adding open source code to your project, but also for sharing components across projects.&lt;/p&gt;

&lt;p&gt;This post will describe how to make a private CocoaPods for your application.
You will need a private spec repository, letting CocoaPods know where to find it and adding the PodSpecs file to the repo.&lt;/p&gt;

&lt;p&gt;Also, you will need a private repository that stores the source code of your pod library and an example project (if you have).&lt;/p&gt;

&lt;h1 id=&quot;pod-creation&quot;&gt;Pod Creation&lt;/h1&gt;

&lt;p&gt;We use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod lib create YOUR_PROJECT_NAME&lt;/code&gt; command to bootstrap the process.
That will automatic generate an entire project by asking you few questions.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What platform do you want to use? [iOS/macOS] -&amp;gt; iOS&lt;/li&gt;
  &lt;li&gt;What language do you want to use? [Swift/ObjC] -&amp;gt; ObjC&lt;/li&gt;
  &lt;li&gt;Would you like to inculde a demo application with your library? [Yes/No] -&amp;gt; Yes&lt;/li&gt;
  &lt;li&gt;Which testing frameworks will you use? [Specta/Kiwi/None] -&amp;gt; None&lt;/li&gt;
  &lt;li&gt;Would you like to view based testing? [Yes/No] -&amp;gt; No&lt;/li&gt;
  &lt;li&gt;What is your class prefix? -&amp;gt; FF&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;directory-of-the-pod-project&quot;&gt;Directory of the Pod project&lt;/h1&gt;

&lt;p&gt;If you finish the few questions, running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod install&lt;/code&gt; on the example folder.
The basic pod library is born.&lt;/p&gt;

&lt;p&gt;You can add your dependency libraries you need like AFNetworking on Podfile or some static frameworks.&lt;/p&gt;

&lt;p&gt;The folder structure will look like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TestPro 
├── Example 
│   ├── Podfile 
│   ├── Podfile.lock 
│   ├── Pods 
│   ├── TestPro 
│   ├── TestPro.xcodeproj 
│   ├── TestPro.xcworkspace 
│   └── Tests 
├── LICENSE 
├── README.md 
├── TestPro 
│   ├── Assets 
│   └── Classes 
├── TestPro.podspec 
└── _Pods.xcodeproj -&amp;gt; Example/Pods/Pods.xcodeproj
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;_Pods.xcodeproj: A symlink to your Pod’s project for Carthage support.&lt;/li&gt;
  &lt;li&gt;TestPro.podspec: The PodSpec of your library, you can add some formulas such as spec name, spec version or the path of source files, and so on. You can find more syntax information on Reference section below.&lt;/li&gt;
  &lt;li&gt;Assets &amp;amp; Classes: That contains all .swift/.h/.m files and images you will need.&lt;/li&gt;
  &lt;li&gt;Pods folder: That stores the external pod libaries you need, including a dynamic framework be installed from Podfile or a static framework you added manually.&lt;/li&gt;
  &lt;li&gt;Example folder: That stores the example project using the Pod library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;add-custom-files-as-you-need&quot;&gt;Add custom files as you need&lt;/h1&gt;

&lt;h4 id=&quot;dynamic-frameworks&quot;&gt;Dynamic frameworks&lt;/h4&gt;

&lt;p&gt;You can use some dependency frameworks through Podfile,
for example,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source 'https://github.com/CocoaPods/Specs.git' 

platform :ios, '8.0' 
use_frameworks! 

inhibit_all_warnings! 

target 'TestPro_Example' do 

	pod 'TestPro', :path =&amp;gt; '../' 
	pod 'AFNetworking' 
	
	target 'TestPro_Tests' do 
		inherit! :search_paths 
	end 
	
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod install&lt;/code&gt;, that will fetch the AFNetworking library into the Pods folder.&lt;/p&gt;

&lt;h4 id=&quot;static-frameworks&quot;&gt;Static frameworks&lt;/h4&gt;

&lt;p&gt;If there are no Pod resource support, you can add the library into the Pods folder by manually.&lt;/p&gt;

&lt;p&gt;Then modify the PodSpec file by adding static_framework and dependency.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;s.static_framework = true 
s.dependency 'AliPay_SDK'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod install&lt;/code&gt;, that will generate the AliPay_SDK library dependency on Xcode.&lt;/p&gt;

&lt;h4 id=&quot;wrappers-files&quot;&gt;Wrappers files&lt;/h4&gt;

&lt;p&gt;You can new some wrapper files on Classes folder that will handle those libraries for usage more easier.&lt;/p&gt;

&lt;h1 id=&quot;push-the-pod-source-code&quot;&gt;Push the Pod source code&lt;/h1&gt;

&lt;p&gt;After you finished features development and write some descriptions on README.md file.&lt;/p&gt;

&lt;p&gt;You need to commit and tag a version number, then push the source code to the remote repository.&lt;/p&gt;

&lt;p&gt;We suggest that the tag number should be equal to the PodSpec version number and follow &lt;a href=&quot;https://semver.org/&quot;&gt;Semantic version define&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git add . 
git commit -m 'First release' 
git tag '1.0.0' 
git push origin master 
git push --tags
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;deploy-the-pod-library&quot;&gt;Deploy the Pod library&lt;/h1&gt;

&lt;p&gt;Using the URL of your private spec repository, adding your repo using:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod repo add POD_NAME THE_URL_OF_SPEC_REPOSITORY&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Save your PodSpec file and add to the repo:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;pod-update&quot;&gt;Pod update&lt;/h1&gt;

&lt;p&gt;Once we modified the Pod library, we need to change the version number on PodSpec file.&lt;/p&gt;

&lt;p&gt;Before you deploy the Pod library, you need to commit, bump up tag version number and push source code to the remote repo under source control.&lt;/p&gt;

&lt;p&gt;If you facing a problem about &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;The TestPro.podspec specification does not validate.&lt;/code&gt; when running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE --verbose --use-libraries --allow-warnings&lt;/code&gt; to resolve it.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html#specification&quot;&gt;Podspec Syntax Reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/using-pod-lib-create&quot;&gt;Using Pod Lib Create&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/private-cocoapods&quot;&gt;Private Pods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://semver.org/&quot;&gt;Semantic Versioning 2.0.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 15:35:29 +0800</pubDate>
        <link>http://localhost:4000/cocoapods/2018/04/15/how-to-make-a-private-cocoapods.html</link>
        <guid isPermaLink="true">http://localhost:4000/cocoapods/2018/04/15/how-to-make-a-private-cocoapods.html</guid>
        
        
        <category>cocoapods</category>
        
      </item>
    
      <item>
        <title>PresentViewController delay on UITableViewCell</title>
        <description>&lt;p&gt;最近開發常常遇到：當點選 UITableViewCell 時去呼叫 presentViewController:animated:completion:，欲開啟的 view controller 會延遲出現的問題，這個似乎是 iOS 7 的 bug，不過之前開發手機卻沒什麼遇到，直到最近開發 iPad 才發現。&lt;/p&gt;

&lt;p&gt;原因是當 UITableViewCell 的 selectionStyle 設為 UITableViewCellSelectionStyleNone，也就是希望不要出現點選效果時，造成沒有動畫效果去觸發 main runloop，所以 thread 好像是睡著了…&lt;/p&gt;

&lt;p&gt;解決方式：&lt;/p&gt;

&lt;p&gt;在呼叫 presentViewController:animated:completion: 後&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;呼叫 CFRunLoopWakeUp(CFRunLoopGetCurrent())&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 執行一個空的 block：dispatch_async(dispatch_get_main_queue(), ^{})&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 直接呼叫 presentViewController:animated:completion:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From: &lt;a href=&quot;http://stackoverflow.com/questions/21075540/presentviewcontrolleranimatedyes-view-will-not-appear-until-user-taps-again&quot;&gt;Stackoverflow 討論&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot;&gt;Thread run loops&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Nov 2015 02:36:24 +0800</pubDate>
        <link>http://localhost:4000/ios/uiview/2015/11/22/presentviewcontroller-delay-on-uitableviewcell.html</link>
        <guid isPermaLink="true">http://localhost:4000/ios/uiview/2015/11/22/presentviewcontroller-delay-on-uitableviewcell.html</guid>
        
        
        <category>ios</category>
        
        <category>uiview</category>
        
      </item>
    
  </channel>
</rss>
