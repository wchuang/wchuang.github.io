<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Frank&#39;s blog - Developer, coffee lover and traveler</title>
    <description>My name is Frank, an iOS developer from Taiwan.  Currently, I work and live in Shanghai, China.
</description>
    <link>http://blog.wchuang.me/</link>
    <atom:link href="http://blog.wchuang.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 18 Jun 2018 21:13:29 +0800</pubDate>
    <lastBuildDate>Mon, 18 Jun 2018 21:13:29 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>What Is Mmap and How It Works?</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;MMAP(Memory-mapped file), 是一種源於 Unix/Linux 作業系統內存映射文件的方法，主要用於&lt;strong&gt;增加 I/O 存取效能&lt;/strong&gt;，尤其大文件效果更顯著。它在進程 process 中開闢一段&lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;虛擬內存&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;逐一字節的將一份文件或檔案從磁碟位置對應到該虛擬位置&lt;/em&gt;，這樣使得 process 可以直接操作該虛擬內存，如同操作該文件，而不需要調用 read/write 等系統方法。同時也減少了一次從文件拷貝的動作。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;原理&lt;/h1&gt;

&lt;p&gt;mmap 實現原理主要分為三個階段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Start MMAP in process, creating a virtual mapping zone on virtual address space:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Process request a &lt;code&gt;mmap&lt;/code&gt; system fuction in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek a continuous and idle virtual address space in vitual memory address of current process.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Allocate a &lt;code&gt;vm_area_struct&lt;/code&gt; struct for this virtual address space, and initialize the struct.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Insert the struct to linked list or tree of virtual address space of process.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Request a &lt;code&gt;mmap&lt;/code&gt; system fuction in kernal-space, not in user-space, and implement the mapping relationship between the disk address of file and virtual address space of current process:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;After allocating a new virtual address space, it will find the file descriptor in file descriptor table by the pointer of un-mapped files. And link to the struct file of every un-mapped file through the file descriptor in kernal’s opened file set. Every struct file will maintain a opened file in kernal one by one.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Link to module of &lt;code&gt;file_operations&lt;/code&gt; through the struct file and request function of &lt;code&gt;mmap&lt;/code&gt; in kernal-space, not in user-space:&lt;/p&gt;

        &lt;p&gt;&lt;code&gt;int mmap(struct file *filp, struct vm_area_struct *vma)&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;code&gt;mmap&lt;/code&gt; function in kernal will locate the file physical address in disk by &lt;code&gt;inode&lt;/code&gt; module.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Build a mapping relationship table between the disk address of file and virtual address space of current process. However, there is no data mapping in main memory from virtual address space.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process start to read data on this virtual address space, that will occur &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%A1%B5%E7%BC%BA%E5%A4%B1&quot;&gt;&lt;code&gt;Page Fault&lt;/code&gt;&lt;/a&gt; and start copy document data from disk to main memory: (&lt;strong&gt;In step 1 and 2, there is only create virtual address space and compelte the mapping relationshop table, but the data do not copy into main memory yet. When starting read/write operations on process, just start to copy data.&lt;/strong&gt;)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;When process start to read or write data on mapping address on virtual address space, it find that it is not found on memory page. Due to there is only build a mapping and the file data is not copy to memory, so it occurs &lt;code&gt;Page Fault&lt;/code&gt;.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Kernal request a page fault handler after confirming there are no illegal operations.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Seek to the memory page in &lt;code&gt;swap cache&lt;/code&gt;, if not find, it will request &lt;code&gt;nopage&lt;/code&gt; function in order to create page from disk to main memory.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Then the process can do read/write operations on main memory, if the data be changed, system will update those changed content in mapped disk address after a while. (You can use &lt;code&gt;msync&lt;/code&gt; function to update data right now.)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-2&quot;&gt;函數介紹&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;參數&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;start: mapping virtual address space 的開始位置，如果傳入 NULL，kernal 會自動選擇 page-aligned address。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;length: mapping space 長度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prot: 內存保護機制。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  PROT_EXEC  Pages may be executed.
  PROT_READ  Pages may be read.
  PROT_WRITE Pages may be written.
  PROT_NONE  Pages may not be accessed.
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flags: 是否該映射區可以被其他 processes 看到。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  MAP_SHARED Share this mapping.
  MAP_SHARED_VALIDATE This flag provides the same behavior as MAP_SHARED except that MAP_SHARED mappings ignore unknown flags in flags.
  MAP_PRIVATE Create a private copy-on-write mapping.
  MAP_32BIT Put the mapping into the first 2 Gigabytes of the process address space. 
  MAP_ANON Synonym for MAP_ANONYMOUS. Deprecated.
  ...    
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fd: 文件描述詞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;offset: 文件位移量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;section-4&quot;&gt;返回值&lt;/h5&gt;

&lt;p&gt;如果建立成功，會返回一個指標指向這個映射空間的位置。假設失敗，將會回傳 &lt;code&gt;MAP_FAILED (that is, (void *) -1)&lt;/code&gt;，以及 &lt;code&gt;errno&lt;/code&gt;。&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;與一般文件存取差異&lt;/h1&gt;

&lt;p&gt;一般文件調用過程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process 發起讀取文件請求。&lt;/li&gt;
  &lt;li&gt;Kernal 通過尋找 file descriptor in file descriptor table，並且利用 kernal 中已開啟的文件集中的文件資訊找到該文件的 &lt;code&gt;inode&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;判斷該文件是否在&lt;a href=&quot;https://en.wikipedia.org/wiki/Page_cache&quot;&gt;頁緩存 page cache&lt;/a&gt; 中，如果存在則返回該文件內容。不存在則利用 &lt;code&gt;inode&lt;/code&gt; 定位到 physical address in disk，並拷貝文件內容到頁緩存中。之後再發起讀頁面請求，將頁緩存的資訊給該 process。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;總而言之，一般文件讀取為了提高效率及保護磁碟，會利用頁緩存技術。這樣造成讀文件的時候，需要先將文件從磁碟拷貝到頁緩存，但由於頁緩存在 kernal-space 中，不能被 user-space 訪問，所以必須將資料從頁緩存再拷貝到 user-space。&lt;strong&gt;這樣進行了兩次的資料拷貝&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;而使用 mmap，利用建立新的 virtual address space 以及磁碟位置與 virtual address space 的映射，沒有進行文件拷貝。直到訪問資料時造成 &lt;code&gt;Page Fault&lt;/code&gt; 利用映射關係，&lt;strong&gt;只進行一次的資料拷貝&lt;/strong&gt;，就從磁碟拷貝至 user-space，讓 process 得以使用。&lt;/p&gt;

&lt;h1 id=&quot;section-6&quot;&gt;優點&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;對文件存取繞過了 paging 技術操作，減少了資料的拷貝次數，並且利用 read/write in memory instead of I/O operations，大大提高效能。&lt;/li&gt;
  &lt;li&gt;內存映射文件可以只載入一部分內容到用戶空間，對於大型檔案非常有用。&lt;/li&gt;
  &lt;li&gt;實現了 user-space 及 kernal-space 的交互，兩空間的修改可以直接反映在映射區，並且被對方更新。&lt;/li&gt;
  &lt;li&gt;可以達到跨 process 溝通通信。&lt;/li&gt;
  &lt;li&gt;避免因為大量的 data I/O 造成的記憶體不足問題，&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;section-7&quot;&gt;如何確保不會讀到其他位址&lt;/h1&gt;

&lt;p&gt;MMAP 是利用自己的虛擬位址空間來處理 (必須先映射，否則無法透過 user-space 的虛擬記憶體存取)。所以其他 user-space 中的行程是沒辦法去存取這塊記憶體。因為其這塊超出的記憶體位址並沒有映射到它自己的虛擬記憶體位址，也因此當 user-space 存取超出的話，就會被作業系統踢出。&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;參考資料&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6&quot;&gt;Wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/huxiao-tee/p/4660352.html&quot;&gt;mmap分析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap函數說明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 18 Jun 2018 17:17:35 +0800</pubDate>
        <link>http://blog.wchuang.me/2018/06/18/what-is-mmap-and-how-it-works/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2018/06/18/what-is-mmap-and-how-it-works/</guid>
        
        
      </item>
    
      <item>
        <title>How to Make a Private CocoaPods</title>
        <description>&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;CocoaPods is a great tool not only for adding open source code to your project, but also for sharing components across projects.&lt;/p&gt;

&lt;p&gt;This post will describe how to make a private CocoaPods for your application.
You will need a private spec repository, letting CocoaPods know where to find it and adding the PodSpecs file to the repo.&lt;/p&gt;

&lt;p&gt;Also, you will need a private repository that stores the source code of your pod library and an example project (if you have).&lt;/p&gt;

&lt;h1 id=&quot;pod-creation&quot;&gt;Pod Creation&lt;/h1&gt;

&lt;p&gt;We use &lt;code&gt;pod lib create YOUR_PROJECT_NAME&lt;/code&gt; command to bootstrap the process.
That will automatic generate an entire project by asking you few questions.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;What platform do you want to use? [iOS/macOS] -&amp;gt; iOS&lt;/li&gt;
  &lt;li&gt;What language do you want to use? [Swift/ObjC] -&amp;gt; ObjC&lt;/li&gt;
  &lt;li&gt;Would you like to inculde a demo application with your library? [Yes/No] -&amp;gt; Yes&lt;/li&gt;
  &lt;li&gt;Which testing frameworks will you use? [Specta/Kiwi/None] -&amp;gt; None&lt;/li&gt;
  &lt;li&gt;Would you like to view based testing? [Yes/No] -&amp;gt; No&lt;/li&gt;
  &lt;li&gt;What is your class prefix? -&amp;gt; FF&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;directory-of-the-pod-project&quot;&gt;Directory of the Pod project&lt;/h1&gt;

&lt;p&gt;If you finish the few questions, running &lt;code&gt;pod install&lt;/code&gt; on the example folder.
The basic pod library is born.&lt;/p&gt;

&lt;p&gt;You can add your dependency libraries you need like AFNetworking on Podfile or some static frameworks.&lt;/p&gt;

&lt;p&gt;The folder structure will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TestPro 
├── Example 
│   ├── Podfile 
│   ├── Podfile.lock 
│   ├── Pods 
│   ├── TestPro 
│   ├── TestPro.xcodeproj 
│   ├── TestPro.xcworkspace 
│   └── Tests 
├── LICENSE 
├── README.md 
├── TestPro 
│   ├── Assets 
│   └── Classes 
├── TestPro.podspec 
└── _Pods.xcodeproj -&amp;gt; Example/Pods/Pods.xcodeproj
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;_Pods.xcodeproj: A symlink to your Pod’s project for Carthage support.&lt;/li&gt;
  &lt;li&gt;TestPro.podspec: The PodSpec of your library, you can add some formulas such as spec name, spec version or the path of source files, and so on. You can find more syntax information on Reference section below.&lt;/li&gt;
  &lt;li&gt;Assets &amp;amp; Classes: That contains all .swift/.h/.m files and images you will need.&lt;/li&gt;
  &lt;li&gt;Pods folder: That stores the external pod libaries you need, including a dynamic framework be installed from Podfile or a static framework you added manually.&lt;/li&gt;
  &lt;li&gt;Example folder: That stores the example project using the Pod library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;add-custom-files-as-you-need&quot;&gt;Add custom files as you need&lt;/h1&gt;

&lt;h4 id=&quot;dynamic-frameworks&quot;&gt;Dynamic frameworks&lt;/h4&gt;

&lt;p&gt;You can use some dependency frameworks through Podfile,
for example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39; 

platform :ios, &#39;8.0&#39; 
use_frameworks! 

inhibit_all_warnings! 

target &#39;TestPro_Example&#39; do 

	pod &#39;TestPro&#39;, :path =&amp;gt; &#39;../&#39; 
	pod &#39;AFNetworking&#39; 
	
	target &#39;TestPro_Tests&#39; do 
		inherit! :search_paths 
	end 
	
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then run &lt;code&gt;pod install&lt;/code&gt;, that will fetch the AFNetworking library into the Pods folder.&lt;/p&gt;

&lt;h4 id=&quot;static-frameworks&quot;&gt;Static frameworks&lt;/h4&gt;

&lt;p&gt;If there are no Pod resource support, you can add the library into the Pods folder by manually.&lt;/p&gt;

&lt;p&gt;Then modify the PodSpec file by adding static_framework and dependency.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.static_framework = true 
s.dependency &#39;AliPay_SDK&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then run &lt;code&gt;pod install&lt;/code&gt;, that will generate the AliPay_SDK library dependency on Xcode.&lt;/p&gt;

&lt;h4 id=&quot;wrappers-files&quot;&gt;Wrappers files&lt;/h4&gt;

&lt;p&gt;You can new some wrapper files on Classes folder that will handle those libraries for usage more easier.&lt;/p&gt;

&lt;h1 id=&quot;push-the-pod-source-code&quot;&gt;Push the Pod source code&lt;/h1&gt;

&lt;p&gt;After you finished features development and write some descriptions on README.md file.&lt;/p&gt;

&lt;p&gt;You need to commit and tag a version number, then push the source code to the remote repository.&lt;/p&gt;

&lt;p&gt;We suggest that the tag number should be equal to the PodSpec version number and follow &lt;a href=&quot;https://semver.org/&quot;&gt;Semantic version define&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add . 
git commit -m &#39;First release&#39; 
git tag &#39;1.0.0&#39; 
git push origin master 
git push --tags
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;deploy-the-pod-library&quot;&gt;Deploy the Pod library&lt;/h1&gt;

&lt;p&gt;Using the URL of your private spec repository, adding your repo using:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pod repo add POD_NAME THE_URL_OF_SPEC_REPOSITORY&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Save your PodSpec file and add to the repo:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&quot;pod-update&quot;&gt;Pod update&lt;/h1&gt;

&lt;p&gt;Once we modified the Pod library, we need to change the version number on PodSpec file.&lt;/p&gt;

&lt;p&gt;Before you deploy the Pod library, you need to commit, bump up tag version number and push source code to the remote repo under source control.&lt;/p&gt;

&lt;p&gt;If you facing a problem about &lt;code&gt;The TestPro.podspec specification does not validate.&lt;/code&gt; when running &lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can run &lt;code&gt;pod repo push POD_NAME YOUR_PODSPEC_FILE --verbose --use-libraries --allow-warnings&lt;/code&gt; to resolve it.&lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html#specification&quot;&gt;Podspec Syntax Reference&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/using-pod-lib-create&quot;&gt;Using Pod Lib Create&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://guides.cocoapods.org/making/private-cocoapods&quot;&gt;Private Pods&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://semver.org/&quot;&gt;Semantic Versioning 2.0.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 15 Apr 2018 15:35:29 +0800</pubDate>
        <link>http://blog.wchuang.me/2018/04/15/how-to-make-a-private-cocoapods/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2018/04/15/how-to-make-a-private-cocoapods/</guid>
        
        
      </item>
    
      <item>
        <title>PresentViewController delay on UITableViewCell</title>
        <description>&lt;p&gt;最近開發常常遇到：當點選 UITableViewCell 時去呼叫 presentViewController:animated:completion:，欲開啟的 view controller 會延遲出現的問題，這個似乎是 iOS 7 的 bug，不過之前開發手機卻沒什麼遇到，直到最近開發 iPad 才發現。&lt;/p&gt;

&lt;p&gt;原因是當 UITableViewCell 的 selectionStyle 設為 UITableViewCellSelectionStyleNone，也就是希望不要出現點選效果時，造成沒有動畫效果去觸發 main runloop，所以 thread 好像是睡著了…&lt;/p&gt;

&lt;p&gt;解決方式：&lt;/p&gt;

&lt;p&gt;在呼叫 presentViewController:animated:completion: 後&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;呼叫 CFRunLoopWakeUp(CFRunLoopGetCurrent())&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 執行一個空的 block：dispatch_async(dispatch_get_main_queue(), ^{})&lt;/li&gt;
  &lt;li&gt;或用 GCD 在 main queue 直接呼叫 presentViewController:animated:completion:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From: &lt;a href=&quot;http://stackoverflow.com/questions/21075540/presentviewcontrolleranimatedyes-view-will-not-appear-until-user-taps-again&quot;&gt;Stackoverflow 討論&lt;/a&gt;, &lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html&quot;&gt;Thread run loops&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Nov 2015 02:36:24 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/11/22/presentviewcontroller-delay-on-uitableviewcell/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/11/22/presentviewcontroller-delay-on-uitableviewcell/</guid>
        
        
        <category>ios</category>
        
        <category>uitableview</category>
        
        <category>uitableviewcell</category>
        
      </item>
    
      <item>
        <title>Custom NSLog</title>
        <description>&lt;pre&gt;&lt;code&gt;#ifdef DEBUG
#   define DLog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);
#else
#   define DLog(...)
#endif

#define ALog(fmt, ...) NSLog((@&quot;%s [Line %d] &quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);

#ifdef DEBUG
#   define ULog(fmt, ...)  { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:[NSString stringWithFormat:@&quot;%s\n [Line %d] &quot;, __PRETTY_FUNCTION__, __LINE__] message:[NSString stringWithFormat:fmt, ##__VA_ARGS__]  delegate:nil cancelButtonTitle:@&quot;Ok&quot; otherButtonTitles:nil]; [alert show]; }
#else
#   define ULog(...)
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加入以上的 code 到 .pch 檔。&lt;/p&gt;

&lt;p&gt;這邊定義了三種不同的 log 方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DLog：相當於 NSLog，但它只有在 DEBUG 模式中才可以被使用。相較於 NSLog，自訂的 function 名稱及程式碼行數也會印出來。&lt;/li&gt;
  &lt;li&gt;ALog：等同 NSLog，function 名稱及程式碼行數也會印出來。&lt;/li&gt;
  &lt;li&gt;ULog：等於用 UIAlertView 印出 DLog。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 14 Oct 2015 01:21:14 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/10/14/custom-nslog/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/10/14/custom-nslog/</guid>
        
        
        <category>ios</category>
        
      </item>
    
      <item>
        <title>Distribute an iOS application OTA</title>
        <description>&lt;p&gt;簡單記錄如何建立給外部使用者或客戶測試的 AdHoc 版本&lt;/p&gt;

&lt;p&gt;iOS app OTA (over the air)，&lt;/p&gt;

&lt;p&gt;而如何產生憑證及 archive 出 AdHoc 就不再贅述了，網路也有很多資源。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;重要的是描述下載位置的 HTML、描述 app 的 plist 檔案以及 app 的 .ipa 檔案，找台伺服器來存放它們吧！這邊推薦使用 Dropbox 方便又好用，當然你也可以用自家 server 或其它 web storage services。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;.ipa 檔：AdHoc 出 .ipa 檔案，並上傳到 Dropbox 底下，點選分享後，會拿到一個分享連結，如 https://www.dropbox.com/s/ooxxaabbcc/ForTestingApp.ipa?dl=0 ，把 www.dropbox.com 改成 dl.dropboxusercontent.com 及 ?dl=0 拿掉，會變成 -&amp;gt; https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.ipa 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;plist 檔：加入一個 Array 的 key，名稱取為 assets，負責描述 .ipa、app icon 兩張（57 * 57）及 (512 * 512) 的分享連結路徑 (與上述 .ipa 檔案ㄧ樣，需放在 dropbox 中，並開啟分享取得連結)，如果不放圖片的話，下載中就看不到 app 的 icon 囉。再加入一個 Dictionary 的 key，名稱取為 metadata，描述 app 相關資訊，如 bundle-identifier、title 或 subtitle 等等。最後一樣開啟分享取得連結。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTML 檔：最後是 HTML，拿來記錄上述 plist 檔的分享位置，並做個畫面呈現給使用者點選下載，可以簡單放上下列程式。&lt;/p&gt;

 	&lt;a href=&quot;itms-services://?action=download-manifest&amp;amp;url=  	https://dl.dropboxusercontent.com/s/ooxxaabbcc/ForTestingApp.plist&quot;&gt;
 	Install this awesome app!&lt;/a&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完成後你就可以把 HTML 的連結給你的朋友或客戶測試囉，不過要記得把手機的 UDID 加進去 Provisioning Profile。&lt;/p&gt;

&lt;p&gt;以上，有不清楚的地方歡迎指教 :p&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Apr 2015 00:53:56 +0800</pubDate>
        <link>http://blog.wchuang.me/2015/04/08/distribute-an-ios-application-ota/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2015/04/08/distribute-an-ios-application-ota/</guid>
        
        
        <category>ios</category>
        
        <category>ota</category>
        
        <category>adhoc</category>
        
        <category>distribute</category>
        
      </item>
    
      <item>
        <title>[UIView viewWithTag:]</title>
        <description>&lt;p&gt;這篇關於使用 [UIView viewWithTag:] 的文章，雖然已是兩年前的，但在下認為文章內所提及的觀念與用法還是很值得與大家分享。&lt;/p&gt;

&lt;p&gt;UIView 有個 tag 屬性以及相對應的方法 -viewWithTag:，讓我們可以輕易的存取特定的 view，而不需要額外的 reference。&lt;/p&gt;

&lt;p&gt;這邊作者分享了幾個使用上常見的問題：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不要使用 tags 來儲存資料，例如：陣列存取物件的索引 (index)…，因為這是一件容易造成後續維護者難以理解你的 code 的一件事…底下是一個使用 button 來呈現圖片縮圖的例子，為了記得哪個按鈕被按到以及要呈現哪個對應於 array 中的圖片索引，所以利用 tag 來記錄。~~(但其實還滿容易這麼幹的啊…在下也常這麼做，要好好檢討了orz)~~&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  - (void)configureThumbnailButton:(UIButton *)thumbnailButton 
                          forPhoto:(NSUInteger)photoIndex {
  		// ...
  	thumbnailButton.tag = 1 + photoIndex;
  		// ...
  }

  - (void)thumbnailButtonTapped:(id)sender {
  		UIButton *thumbnailButton = sender;
  		NSUInteger photoIndex = thumbnailButton.tag - 1;
  		id selectedPhoto = [self.photoArray objectAtIndex:photoIndex];
  		[self showPhoto:selectedPhoto];
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存取 view 額外資料的幾個比較正確的方式：&lt;/p&gt;

    &lt;p&gt;我們來探討一下為什麼會寫出上述例子的程式碼，其實也只是想要知道 button 對應的 index，或是 button 真正對應的圖片縮圖，此時更適合的方式應該是另外做一個 custom subClass 來儲存這些有用的額外資料，延續上述例子，應該可以這麼做：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  @interface PhotoThumbnailButton : UIButton

  @property (nonatomic, assign) NSInteger photoIndex;
  // OR
  @property (nonatomic, strong) Photo *photo;

  @end
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;這時候你會說，如果每次都要這樣也太麻煩了吧！的確，每次都要建個 subClass 有時可能不符合實際情況，底下也提供一個用法：Associated references。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://goo.gl/6fM6Kq&quot;&gt;Associated references&lt;/a&gt;：提供了 objc_getAssociatedObject 以及 objc_setAssociatedObject 等方法，可以利用特定的 key 及 policy 存取特定的 obejct。如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #import &amp;lt;objc/runtime.h&amp;gt;

  static char kThumbnailButtonAssociatedPhotoKey;

  // ...

  - (void)setAssociatedPhoto:(Photo *)associatedPhoto
          forThumbnailButton:(UIButton *)thumbnailButton {
  		objc_setAssociatedObject(thumbnailButton,
  		                         &amp;amp;kThumbnailButtonAssociatedPhotoKey,
                               associatedPhoto,
                               OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  }

  - (Photo *)associatedPhotoForThumbnailButton:(UIButton *)thumbnailButton {
      return objc_getAssociatedObject(thumbnailButton,
                              		 &amp;amp;kThumbnailButtonAssociatedPhotoKey);
  }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;存取時，&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;	- (void)configureThumbnailButtonForPhoto:(Photo *)photo {
  		// ...
  		[self setAssociatedPhoto:photo forThumbnailButton:thumbnailButton];
  		// ...
  }

  - (void)thumbnailButtonTapped {
  		Photo *photo = [self associatedPhotoForThumbnailButton:thumbnailButton];
  		// ...
  }
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;真的是很酷啊… 可是，如果只是想要快速直接的知道是哪一個 view，這樣的方式還是不夠直覺…所以，有些情況下，你還是會想直接利用 UIView’s tag 存取，但重點是請遵循 UIView’s tag 是 UIView 的唯一識別、可讀性以及易維護性的觀念，而使用 #define 或 enum value 來設定 tags，在你之後的開發者會很感謝你的..XD，例如：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  enum MyViewTags {
      kTitleLabelTag = 1,
  		kSendButtonTag,
  		kSomeOtherViewTag
  };

  // ...

  if (sender.tag == kSendButtonTag) {
  		// ...
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;結論：
    &lt;ul&gt;
      &lt;li&gt;不要使用 tags 來儲存資料 -&amp;gt; use sub-class or associated references resolving this.&lt;/li&gt;
      &lt;li&gt;多利用 public properties of sub-class for getting references of subviews.&lt;/li&gt;
      &lt;li&gt;If you do use tags, do not use magic numbers. Use named constants.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://goo.gl/0xHqWt&quot;&gt;Ref.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 11 Nov 2014 01:46:01 +0800</pubDate>
        <link>http://blog.wchuang.me/2014/11/11/uiview-viewwithtag/</link>
        <guid isPermaLink="true">http://blog.wchuang.me/2014/11/11/uiview-viewwithtag/</guid>
        
        
        <category>viewwithtag</category>
        
        <category>uiview</category>
        
        <category>objective-c</category>
        
        <category>ios</category>
        
        <category>uikit</category>
        
      </item>
    
  </channel>
</rss>
